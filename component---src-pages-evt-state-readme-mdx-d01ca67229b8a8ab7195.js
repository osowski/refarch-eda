(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{llbQ:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return o})),a.d(t,"default",(function(){return p}));a("91GP"),a("rGqo"),a("yt8O"),a("Btvt"),a("RW0V"),a("q1tI");var n=a("7ljp"),r=a("013z");a("qKvR");function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}var o={},i={_frontmatter:o},c=r.a;function p(e){var t=e.components,a=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,["components"]);return Object(n.b)(c,s({},i,a,{components:t,mdxType:"MDXLayout"}),Object(n.b)("p",null,"While the prime focus for an event-driven architecture is processing events, in certain cases you need to persist events for post processing and queries by other applications. The event backbone has a built-in event log that can be used to store and reply to events that are published to the backbone. However, considering the full scope of event-driven solutions, other use cases and types of store can be supported:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"Event stores optimized for analytics."),Object(n.b)("li",{parentName:"ul"},"Event sourcing as a pattern for recording state changes and updates across distributed systems."),Object(n.b)("li",{parentName:"ul"},"Command Query Response Separation (CQRS) as an optimization that separates updates and reads across different stores.")),Object(n.b)("h2",null,"Event sourcing"),Object(n.b)("p",null,"When the state of a system changes, an application issues a notification event of the state change. We are detailing this pattern ",Object(n.b)("a",s({parentName:"p"},{href:"../design-patterns/event-sourcing/"}),"here >>")," "),Object(n.b)("h2",null,"Command Query Responsibility Segregation (CQRS)"),Object(n.b)("p",null,"The event log leads to more work to support business query as it requires converting the events into the application state suitable to the query."),Object(n.b)("p",null,"We are detailing this pattern ",Object(n.b)("a",s({parentName:"p"},{href:"../design-patterns/cqrs/"}),"here >>")," "),Object(n.b)("p",null,"See the following ",Object(n.b)("a",s({parentName:"p"},{href:"https://github.com/ibm-cloud-architecture/refarch-kc-order-ms"}),"order management project")," for a detail explanation and implementation of the CQRS and event sourcing patterns."),Object(n.b)("h2",null,"Event sourcing, CQRS and microservices"),Object(n.b)("p",null,"With the adoption of microservices you have explicitly separated state, so that a microservice is bounded with its own state. Further, with the use of event sourcing, you create a history log that is not easy to query. The challenge now comes when you need to implement a query that requires a joining of data from multiple services.\nThere are multiple choices to address service orchestration: API composition or the CQRS pattern. For API composition the query is supported by an operation which integrate with all other microservices and may do some data transformation to combine the results. With this pattern you need to assess for aggregation requirements as they may dramatically impact performance. You may need to assess where to put this API composition component. It can be an API gateway or part of a BFF or even its own microservices.\nThe other answer is to implement a CQRS pattern where state changes are published as events by multiple related business objects. Each change is persisted in the event log or event store, and a higher level operation subscribes to each event and persists the data in a queryable data store."),Object(n.b)("h2",null,"Fearther readings"),Object(n.b)("p",null,"Read more on this pattern at ",Object(n.b)("a",s({parentName:"p"},{href:"https://microservices.io/patterns/data/cqrs.html"}),"https://microservices.io/patterns/data/cqrs.html")," and our ",Object(n.b)("a",s({parentName:"p"},{href:"https://github.com/ibm-cloud-architecture/refarch-kc-order-ms"}),"reference implementation")),Object(n.b)("h2",null,"Supporting Products"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",s({parentName:"li"},{href:"https://console.bluemix.net/catalog/services/event-streams"}),"IBM Event Streams Public Cloud")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",s({parentName:"li"},{href:"https://www.ibm.com/cloud/event-streams"}),"IBM Event Streams Private Cloud")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",s({parentName:"li"},{href:"https://www.ibm.com/products/db2-event-store"}),"IBM Db2 Event store"))))}p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-evt-state-readme-mdx-d01ca67229b8a8ab7195.js.map