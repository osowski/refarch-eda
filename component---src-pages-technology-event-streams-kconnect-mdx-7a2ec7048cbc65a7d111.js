(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{"15H9":function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return c})),t.d(n,"default",(function(){return d}));var a=t("wx14"),o=t("zLVn"),r=(t("q1tI"),t("7ljp")),i=t("013z"),c=(t("qKvR"),{}),s=function(e){return function(n){return console.warn("Component '"+e+"' was not imported, exported, or provided by MDXProvider as global scope"),Object(r.b)("div",n)}},l=s("AnchorLinks"),b=s("AnchorLink"),p=s("InlineNotification"),m={_frontmatter:c},u=i.a;function d(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(r.b)(u,Object(a.a)({},m,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)(l,{mdxType:"AnchorLinks"},Object(r.b)(b,{mdxType:"AnchorLink"},"Overview"),Object(r.b)(b,{mdxType:"AnchorLink"},"Solution anatomy"),Object(r.b)(b,{mdxType:"AnchorLink"},"General pre-requisites"),Object(r.b)(b,{mdxType:"AnchorLink"},"Scenario setup"),Object(r.b)(b,{mdxType:"AnchorLink"},"Scenario 1: Event Streams on Cloud to MQ on premise via MQ connector sink"),Object(r.b)(b,{mdxType:"AnchorLink"},"Scenario 2: Deploying Kafka Connector MQ Sink to OpenShift"),Object(r.b)(b,{mdxType:"AnchorLink"},"Scenario 3: Rabbitmq on premise to Event Streams on Cloud via RabbitMQ connector source"),Object(r.b)(b,{mdxType:"AnchorLink"},"Scenario 4: Event Streams on Cloud to DB2 on premise via JDBC Sink connector"),Object(r.b)(b,{mdxType:"AnchorLink"},"Scenario 5: Run the solution components end to end on Kubernetes")),Object(r.b)("h2",null,"Overview"),Object(r.b)("p",null,"This lab will address multiple scenarios that aim to build an end to end data pipeline, as depicted by the following figure, using Event Streams on Cloud. At the high level Kafka connect is used to integrate external systems into the Kafka ecosystem. For example external system can inject message to queue manager, from which a first Kafka source connector will get the message to a Kafka topic, which then will be processed by a series of event driven microservices down to a final topic, that will be use by Sink connectors."),Object(r.b)("img",{src:"./images/kconnect-overview.png",alt:"1"}),Object(r.b)("p",null,"To support this lab we are reusing a classical business use case where stores are sending their transactions to a central messaging platform, based on queues, and with the adoption of loosely coupled microservice, real time analytics and complex event processing, Kafka is added to the legacy environment. Adopting Kafka connect lets integrate with existing applications without any changes."),Object(r.b)("h2",null,"Solution anatomy"),Object(r.b)("p",null,"The lab is divided into scenarios that can be combined to support the real time inventory data pipeline as illustrated in the figure below:"),Object(r.b)("img",{src:"./images/kconnect-scenario-components.png",alt:"2"}),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"The store application, is a Quarkus based app, generating item sales to RabbitMQ ",Object(r.b)("inlineCode",{parentName:"p"},"items")," queue. The code of this application is under the ",Object(r.b)("inlineCode",{parentName:"p"},"store-sale-producer")," folder, in the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jbcodeforce/eda-kconnect-lab/"}),"lab repository"),". We will address how to get this code in the pre-requisite section."),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"RabbitMQ runs in docker image started locally via docker compose. The messages are in the ",Object(r.b)("inlineCode",{parentName:"li"},"items")," queue."),Object(r.b)("li",{parentName:"ul"},"The lab, focusing on the injection to Kafka, is documented in the ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#scenario-2:-rabbitmq-on-premise-to-event-streams-on-cloud-via-rabbitmq-connector-source"}),"scenario 2"),"."),Object(r.b)("li",{parentName:"ul"},"[A]"," The Sink connector description is in the ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/jbcodeforce/eda-kconnect-lab/tree/master/kconnect"}),"kconnect")," folder."),Object(r.b)("li",{parentName:"ul"},"Kafka backbone is Event Streams on Cloud."))),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"The inventory MS is a Kafka Stream application, done with Reactive Messaging and Kafka Stream API. The folder is\nFor example the scenario illustrate JDBC Sink connector to save to existing data base.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"The mock up Inventory mainframe application is not implemented and we will use the MQ tools to view the message in the ",Object(r.b)("inlineCode",{parentName:"p"},"inventory")," queue"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"The MQ Sink connector ","[B]"," configuration is defined in the ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/jbcodeforce/eda-kconnect-lab/tree/master/kconnect"}),"kconnect")," folder."),Object(r.b)("li",{parentName:"ul"},"MQ broker runs in docker container started with docker-compose"),Object(r.b)("li",{parentName:"ul"},"The lab scenario is ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#scenario-1:-event-streams-on-cloud-to-mq-on-premise-via-mq-connector-sink"}),"the number 1")))),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"The Inventory Application, using DB2 as datasource is a quarkus app using hibernate with panache, defined in the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jbcodeforce/eda-kconnect-lab/tree/master/inventory-app"}),"nventory-app")," folder"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"The JDBC Sink connector ","[C]"," configuration is defined in the ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/jbcodeforce/eda-kconnect-lab/tree/master/kconnect"}),"kconnect")," folder."),Object(r.b)("li",{parentName:"ul"},"The ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#scenario-3:-event-streams-on-cloud-to-db2-on-premise-via-jdbc-sink-connector"}),"scenario 3")," lab goes over how the Kafka Connect JDBC sink works."))),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"The ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#scenario-4:-run-the-solution-components-end-to-end-on-kubernetes"}),"scenario 4")," addresses the end to end solution, which is basically an end to end demonstration of a simple data pipeline for a real time view of an inventory solution."))),Object(r.b)(p,{kind:"info",mdxType:"InlineNotification"},"You need to decide what your 'on-premise' environment is for this lab. You can run with docker compose, or deploy on a premise cluster. We propose to run the components with docker compose for the scenario 1,2,3 and scenario 4 is for a deployment of the components on a kubernetes cluster that could run on premise or on any cloud provider using Openshift. If you do not want to build all the components, we have each of them available in docker hub and the docker compose file should run them automatically."),Object(r.b)("h2",null,"General pre-requisites"),Object(r.b)("p",null,"We need the following IBM Cloud services created and tools to run the lab. We try to use docker images as much as possible to do not impact your local laptop."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://docs.docker.com/"}),"Docker")," and docker compose to run the solution locally."),Object(r.b)("li",{parentName:"ul"},"Event Streams instance, may be reuse the one created in ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"/refarch-eda/technology/event-streams/es-cloud/"}),"this lab"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://cloud.ibm.com/docs/cli?topic=cli-getting-started"}),"IBM Cloud CLI"),"."),Object(r.b)("li",{parentName:"ul"},"If you want to run locally you need to get ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://docs.docker.com/compose/"}),"docker compose"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://git-scm.com/downloads"}),"git CLI"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://maven.apache.org/install.html"}),"Maven"),".")),Object(r.b)("p",null,"For the on-premise environment, we will not use VMs, but simply run some of the components on IBM premise Service platform or Openshift. The point is that the workload is packaged as container images and can run anywhere."),Object(r.b)("h2",null,"Scenario setup"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Login to the cloud via CLI: ",Object(r.b)("inlineCode",{parentName:"p"},"ibmcloud login"))),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Initialize the Event Streams CLI and select the target Event Streams cluster: ",Object(r.b)("inlineCode",{parentName:"p"},"ibmcloud es init"))),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Define connect topics: When running in distributed mode, the connectors need three topics as presented in the ",Object(r.b)("inlineCode",{parentName:"p"},"create topics")," table ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://ibm.github.io/event-streams/connecting/setting-up-connectors/"}),"here"),"."),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"connect-configs"),": This topic will store the connector and task configurations."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"connect-offsets"),": This topic is used to store offsets for Kafka Connect."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"connect-status"),": This topic will store status updates of connectors and tasks.")),Object(r.b)("p",{parentName:"li"},"Using IBM Event Streams CLI, the topics are created via the commands like:"),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"# log to the kubernetes cluster:\nibmcloud login -a https://icp-console.apps.green.ocp.csplab.local\n# initialize the event streams CLI plugin\nibmcloud es init\n# Create the Kafka topics for Kafka connect\nibmcloud es topic-create -n connect-configs -p 1 -r 3 -c cleanup.policy=compact\nibmcloud es topic-create -n connect-offsets -p 25 -r 3 -c cleanup.policy=compact\nibmcloud es topic-create -n connect-status -p 5 -r 3 -c cleanup.policy=compact\n# Create the topic for the scenarios\nibmcloud es topic-create inventory\nibmcloud es topic-create items\nibmcloud es topics\n"))),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Create API KEY with a manager-level access.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Clone the lab repository: ",Object(r.b)("inlineCode",{parentName:"p"},"git clone https://github.com/jbcodeforce/eda-kconnect-lab && cd eda-kconnect-lab"),".")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Prepare the script to set the environment variables used by all the components of the solution, like the Kafka broker URLs and APIKEy."),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"First rename the ",Object(r.b)("inlineCode",{parentName:"li"},"scripts/setenv-TMP.sh")," to ",Object(r.b)("inlineCode",{parentName:"li"},"scripts/setenv.sh")),Object(r.b)("li",{parentName:"ul"},"Then modify the KAFKA_BROKERS and KAFKA_APIKEY with the respecting values as defined in the Event Streams credentials.")),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n  "api_key": "bA ... Qp",\n  "apikey": "bA ... Qp",\n  "iam_apikey_description": "Auto-generated for key 4d ... c6",\n  "iam_apikey_name": "es-mgr-creds",\n  "iam_role_crn": "crn:v1:bluemix:public:iam::::serviceRole:Manager",\n  "iam_serviceid_crn": "crn:v1:bluemix:public:iam-identity::a/db ... f2::serviceid:ServiceId-7a ... 6d",\n  "instance_id": "29 ... 15",\n  "kafka_admin_url": "https://70 ... 1g.svc01.us-east.eventstreams.cloud.ibm.com",\n  "kafka_brokers_sasl": [\n    "broker-1- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093",\n    "broker-0- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093",\n    "broker-4- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093",\n    "broker-2- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093",\n    "broker-5- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093",\n    "broker-3- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093"\n  ],\n  "kafka_http_url": "https://70 ... 1g.svc01.us-east.eventstreams.cloud.ibm.com",\n  "password": "bA ... Qp",\n  "user": "token"\n}\n'))),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Prepare the Kafka Connect environment, as we need to use three connectors. Therefore we need to clone the source, build and get the jars file in the connectors. In fact we have developed scripts to automate those tedious steps:"))),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Under the ",Object(r.b)("inlineCode",{parentName:"li"},"kconnect")," folder run ",Object(r.b)("inlineCode",{parentName:"li"},"./setupConnectors.sh")," script and get the three connectors downloaded and built."),Object(r.b)("li",{parentName:"ul"},"Build a docker image for the connector: this is also done by running a second script: ",Object(r.b)("inlineCode",{parentName:"li"},"./createOrStartKconnect.sh build"),".")),Object(r.b)(p,{kind:"info",mdxType:"InlineNotification"},"You need to decide what 'on-premise' environment is for this lab. You can run with docker compose, or deploy on a premise cluster. We propose to run the components with docker compose for the scenario 1,2,3 and do a deployment of the components on premise as a service on scenario 4."),Object(r.b)("h2",null,"Scenario 1: Event Streams on Cloud to MQ on premise via MQ connector sink"),Object(r.b)("p",null,"This scenario uses the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/ibm-messaging/kafka-connect-mq-sink"}),"IBM Kafka Connect sink connector for IBM MQ")," to pull streaming data into a local MQ queue.  In this example we are using IBM Event Streams on IBM Cloud as the Kafka data source and a dockerized instance of MQ as the destination. We could have used MQ broker as part of Cloud Pak for integration or ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://cloud.ibm.com/docs/mqcloud/index.html"}),"as a service in IBM Cloud"),"."),Object(r.b)("h3",null,"Pre-requisites"),Object(r.b)("p",null,"We assume that you have an instance of Event Streams already running on IBM Cloud with at least on manager-level credentials created.  The credentials will come in the form of a JSON document as seen in the previous section.\nYou will need the ",Object(r.b)("inlineCode",{parentName:"p"},"kafka_brokers_sasl")," and ",Object(r.b)("inlineCode",{parentName:"p"},"password")," atribute to configure the sink connector."),Object(r.b)("p",null,"This scenario uses the ",Object(r.b)("inlineCode",{parentName:"p"},"inventory")," topic created in the Scenario Setup in previous section."),Object(r.b)("h3",null,"Create Local IBM MQ Instance"),Object(r.b)("p",null,"Here we will use Docker to create a local MQ instance.  First create a data directory to mount in the container."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"mkdir qm1data")),Object(r.b)("p",null,"Then create the container."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"docker run                     \\\n  --name mq                    \\\n  --detach                     \\\n  --publish 1414:1414          \\\n  --publish 9443:9443          \\\n  --publish 9157:9157          \\\n  --volume qm1data:/mnt/mqm    \\\n  --env LICENSE=accept         \\\n  --env MQ_QMGR_NAME=QM1       \\\n  --env MQ_APP_PASSWORD=admin  \\\n  --env MQ_ENABLE_METRICS=true \\\n  ibmcom/mq\n")),Object(r.b)("p",null,"You should be able to log into the MQ server on port 9443 with default user ",Object(r.b)("inlineCode",{parentName:"p"},"admin")," and password ",Object(r.b)("inlineCode",{parentName:"p"},"passw0rd"),"."),Object(r.b)("p",null,"Connect to the running MQ instance to create a Channel and Queue as described on the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/ibm-messaging/kafka-connect-mq-sink/blob/master/UsingMQwithKafkaConnect.md"}),"Using IBM MQ with Kafka Connect")," page."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"docker exec -ti mq bash\nstrmqm QM1\nrunmqsc QM1\nDEFINE CHANNEL(KAFKA.CHANNEL) CHLTYPE(SVRCONN)\nSET CHLAUTH(KAFKA.CHANNEL) TYPE(BLOCKUSER) USERLIST('nobody')\nSET CHLAUTH('*') TYPE(ADDRESSMAP) ADDRESS('*') USERSRC(NOACCESS)\nSET CHLAUTH(KAFKA.CHANNEL) TYPE(ADDRESSMAP) ADDRESS('*') USERSRC(CHANNEL) CHCKCLNT(REQUIRED)\nALTER AUTHINFO(SYSTEM.DEFAULT.AUTHINFO.IDPWOS) AUTHTYPE(IDPWOS) ADOPTCTX(YES)\nREFRESH SECURITY TYPE(CONNAUTH)\nDEFINE QLOCAL(INVENTORY)\nSET AUTHREC OBJTYPE(QMGR) PRINCIPAL('admin') AUTHADD(CONNECT,INQ)\nSET AUTHREC PROFILE(INVENTORY) OBJTYPE(QUEUE) PRINCIPAL('admin') AUTHADD(ALLMQI)\nEND\n")),Object(r.b)("p",null,"Exit the session and continue on to create the MQ Connector Sink."),Object(r.b)("h3",null,"Create MQ Kafka Connector Sink"),Object(r.b)("p",null,"The MQ Connector Sink can be downloaded from ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/ibm-messaging/kafka-connect-mq-sink"}),"Github"),".  The Github site includes exhaustive instructions and an abridged version follows."),Object(r.b)("p",null,"Clone the repository with the following command:"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"git clone https://github.com/ibm-messaging/kafka-connect-mq-sink.git")),Object(r.b)("p",null,"Change directory into the kafka-connect-mq-sink directory:"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"cd kafka-connect-mq-sink")),Object(r.b)("p",null,"Build the connector using Maven:"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"mvn clean package")),Object(r.b)("p",null,"Next, create a directory to contain the Kafka Connector configuration."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"mkdir config && cd config")),Object(r.b)("p",null,"Create a configuration file called ",Object(r.b)("inlineCode",{parentName:"p"},"connect-distributed.properties")," for Kafka Connect based on the template below."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-properties"}),'# A list of host/port pairs to use for establishing the initial connection to the Kafka cluster.\nbootstrap.servers=broker-1- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-0- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-4- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-2- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-5- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-3- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093\nssl.enabled.protocols=TLSv1.2\nssl.protocol=TLS\nsecurity.protocol=SASL_SSL\nsasl.mechanism=PLAIN\nsasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="token" password="bA ... Qp";\n\n# Consumer side configuration\nconsumer.bootstrap.servers=broker-1- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-0- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-4- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-2- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-5- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-3- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093\nconsumer.security.protocol=SASL_SSL\nconsumer.ssl.protocol=TLSv1.2\nconsumer.sasl.mechanism=PLAIN\nconsumer.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="token" password="bA ... Qp";\n\n# Producer Side\nproducer.security.protocol=SASL_SSL\nproducer.ssl.protocol=TLSv1.2\nproducer.sasl.mechanism=PLAIN\nproducer.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="token" password="bA ... Qp";\nproducer.bootstrap.servers=broker-1- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-0- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-4- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-2- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-5- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-3- ... kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093\n\n\nplugin.path=/opt/kafka/libs\n\n# unique name for the cluster, used in forming the Connect cluster group. Note that this must not conflict with consumer group IDs\ngroup.id=mq-sink-cluster\n\n# The converters specify the format of data in Kafka and how to translate it into Connect data. Every Connect user will\n# need to configure these based on the format they want their data in when loaded from or stored into Kafka\nkey.converter=org.apache.kafka.connect.json.JsonConverter\nvalue.converter=org.apache.kafka.connect.json.JsonConverter\n# Converter-specific settings can be passed in by prefixing the Converter\'s setting with the converter we want to apply\n# it to\nkey.converter.schemas.enable=true\nvalue.converter.schemas.enable=true\n\n# Topic to use for storing offsets. T\noffset.storage.topic=connect-offsets\noffset.storage.replication.factor=3\n#offset.storage.partitions=25\n\n# Topic to use for storing connector and task configurations; note that this should be a single partition, highly replicated, and compacted topic.\nconfig.storage.topic=connect-configs\nconfig.storage.replication.factor=3\n\n# Topic to use for storing statuses. This topic can have multiple partitions and should be replicated and compacted.\nstatus.storage.topic=connect-status\nstatus.storage.replication.factor=3\nstatus.storage.partitions=5\n\n# Flush much faster than normal, which is useful for testing/debugging\noffset.flush.interval.ms=10000\n')),Object(r.b)("p",null,"Save this file in the ",Object(r.b)("inlineCode",{parentName:"p"},"config")," directory."),Object(r.b)("p",null,"Next, create a log4j configuration file named ",Object(r.b)("inlineCode",{parentName:"p"},"connect-log4j.properties")," based on the template below."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-properties"}),"log4j.rootLogger=DEBUG, stdout\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=[%d] %p %m (%c:%L)%n\n\nlog4j.logger.org.apache.kafka=INFO\n")),Object(r.b)("p",null,"Save this file to the ",Object(r.b)("inlineCode",{parentName:"p"},"config")," directory as well."),Object(r.b)("p",null,"Finally, create a JSON configuraiton file for the MQ sink.  This can be stored anywhere but it can be conveniently created in the ",Object(r.b)("inlineCode",{parentName:"p"},"config")," directory.  We name this file ",Object(r.b)("inlineCode",{parentName:"p"},"mq-sink.json"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n    "name": "mq-sink",\n    "config":\n    {\n        "connector.class": "com.ibm.eventstreams.connect.mqsink.MQSinkConnector",\n        "tasks.max": "1",\n        "topics": "inventory",\n\n        "key.converter": "org.apache.kafka.connect.storage.StringConverter",\n        "value.converter": "org.apache.kafka.connect.storage.StringConverter",\n\n        "mq.queue.manager": "QM1",\n        "mq.connection.name.list": "mq(1414)",\n        "mq.user.name": "admin",\n        "mq.password": "passw0rd",\n        "mq.user.authentication.mqcsp": true,\n        "mq.channel.name": "KAFKA.CHANNEL",\n        "mq.queue": "INVENTORY",\n        "mq.message.builder": "com.ibm.eventstreams.connect.mqsink.builders.DefaultMessageBuilder"\n    }\n}\n')),Object(r.b)("p",null,"Back out one directory to the ",Object(r.b)("inlineCode",{parentName:"p"},"kafka-connect-mq-sink")," directory."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"cd ..")),Object(r.b)("p",null,"Build docker image\n",Object(r.b)("inlineCode",{parentName:"p"},"docker build -t kafkaconnect-with-mq-sink:1.3.0 .")),Object(r.b)("p",null,"Finally, run the Kafka Connect MQ Sink container."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"docker run                                 \\\n  --name mq-sink                           \\\n  --detach                                 \\\n  --volume $(pwd)/config:/opt/kafka/config \\\n  --publish 8083:8083                      \\\n  --link mq:mq                             \\\n  kafkaconnect-with-mq-sink:1.3.0\n")),Object(r.b)("p",null,"You should now have a working MQ sink."),Object(r.b)("p",null,"As an alternate approach, when you have a Kafka Connect isntance up and running, with the dependant jar files, it is possible to configure the connector with a POST operation like:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-Shell"}),'curl -X POST -H "Content-Type: application/json" http://localhost:8083/connectors   --data "@./mq-sink.json"\n\n# The response returns the metadata about the connector\n{"name":"mq-sink","config":{"connector.class":"com.ibm.eventstreams.connect.mqsink.MQSinkConnector","tasks.max":"1","topics":"inventory","key.converter":"org.apache.kafka.connect.storage.StringConverter","value.converter":"org.apache.kafka.connect.storage.StringConverter","mq.queue.manager":"QM1","mq.connection.name.list":"ibmmq(1414)","mq.user.name":"admin","mq.password":"passw0rd","mq.user.authentication.mqcsp":"true","mq.channel.name":"KAFKA.CHANNEL","mq.queue":"INVENTORY","mq.message.builder":"com.ibm.eventstreams.connect.mqsink.builders.DefaultMessageBuilder","name":"mq-sink"},"tasks":[{"connector":"mq-sink","task":0}],"type":"sink"}\n')),Object(r.b)("p",null,"Once the connector is up and running, we can use some tool to send inventory message. In the ",Object(r.b)("inlineCode",{parentName:"p"},"integration-tests")," folder we have some python code to produce message. If you have a python environment with kafka api you can use yours, or we have also provided a Dockerfile to prepare a local python environment, which will not impact yours."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"# if you change the name of the image\ndocker build -t ibmcase/python37 .\n# ... then update the script ./startPython.sh\n./startPython.sh\n# Now in the new bash session you should see ProduceInventoryEvent.py,... start it by sending 2 events\npython ProduceInventoryEvent.py --size 2\n# Events are random but use stores and items known by the database downstream.\n sending -> {'storeName': 'NYC01', 'itemCode': 'IT06', 'quantity': 15, 'price': 163, 'id': 1, 'timestamp': '23-Jun-2020 04:32:38'}\n# the following trace demonstrates Kafka received the message\n[KafkaProducer] - Message delivered to inventory [0]\nsending -> {'storeName': 'SC01', 'itemCode': 'IT06', 'quantity': 15, 'price': 178, 'id': 2, 'timestamp': '23-Jun-2020 04:32:38'}\n[KafkaProducer] - Message delivered to inventory [0]\n")),Object(r.b)("p",null,"In the Kafka Connect trace we can see:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kconnect_1  | [2020-06-23 04:23:16,270] INFO WorkerSinkTask{id=mq-sink-0} Committing offsets asynchronously using sequence number 26: {inventory-0=OffsetAndMetadata{offset=44, leaderEpoch=null, metadata=''}} (org.apache.kafka.connect.runtime.WorkerSinkTask:349)\nkconnect_1  | [2020-06-23 04:32:46,382] INFO WorkerSinkTask{id=mq-sink-0} Committing offsets asynchronously using sequence number 83: {inventory-0=OffsetAndMetadata{offset=48, leaderEpoch=null, metadata=''}} (org.apache.kafka.connect.runtime.WorkerSinkTask:349)\n")),Object(r.b)("p",null,"And in the IBM MQ Console, under the Local Queue: Inventory we can see the messages:"),Object(r.b)("img",{src:"./images/ibmq-q-inventory.png",alt:null}),Object(r.b)("p",null,"To remove the connector do the following command. Do this specially if you go to scenario 2 next."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"curl -X DELETE http://localhost:8083/connectors/mq-sink\n")),Object(r.b)("h2",null,"Scenario 2: Deploying Kafka Connector MQ Sink to OpenShift"),Object(r.b)("h3",null,"Prerequisites"),Object(r.b)("p",null,"We are assuming you already have an instance of IBM EventStreams running on IBM Cloud from previous scenarios.  Also, we assume you have a running instance of OpenShift with a project created to run the MQ Sink.  Finally, we assume you’re familia with OpenShift and Kubernetes and will know how to work with the configuration files provided below."),Object(r.b)("h3",null,"MQ on OpenShift"),Object(r.b)("p",null,"Strictly speaking you don’t need to move the instance of MQ previously used onto OpenShift for the MQ Sink to work however the configuration to do so is provided.  Note that this is not a production configuration and is intended for POC purposes only."),Object(r.b)("p",null,"Create a ConfigMap on OpenShift with the following definition:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'kind: ConfigMap\napiVersion: v1\nmetadata:\n  name: mq-config\n  namespace: mq-demo\ndata:\n    LICENSE: accept\n    MQ_QMGR_NAME: QM1\n    MQ_APP_PASSWORD: admin\n    MQ_ENABLE_METRICS: "true"\n')),Object(r.b)("p",null,"This will make it easier to update the MQ configuration if needed without editing everything in the Pod definition."),Object(r.b)("p",null,"Next, create the MQ Pod with the following definition:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: v1\nkind: Pod\nmetadata:\n  name: ibm-mq\n  labels:\n    app: mq-kafka-sink-demo-app\n  namespace: mq-demo\nspec:\n  containers:\n    - name: ibm-mq\n      image: ibmcom/mq\n      ports:\n        - containerPort: 1414\n          protocol: TCP\n        - containerPort: 9443\n          protocol: TCP\n        - containerPort: 9157\n          protocol: TCP\n      envFrom:\n        - configMapRef:\n            name: mq-config\n")),Object(r.b)("p",null,"Next, define a Service to point to the MQ Pod."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: v1\nkind: Service\nmetadata:\n  name: mq-service\n  namespace: mq-demo\nspec:\n  selector:\n    app: mq-kafka-sink-demo-app\n  ports:\n    - name: mq-port\n      protocol: TCP\n      port: 1414\n      targetPort: 1414\n    - name: mq-portal\n      protocol: TCP\n      port: 9443\n      targetPort: 9443\n    - name: mq-dunno\n      protocol: TCP\n      port: 9157\n      targetPort: 9157\n")),Object(r.b)("p",null,"Finally, define a Route to be able to access the admin UI."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"kind: Route\napiVersion: route.openshift.io/v1\nmetadata:\n  name: mq-route\n  namespace: mq-demo\nspec:\n  host: ibmmq.bnpp.apps.openshift.proxmox.lab\n  to:\n    kind: Service\n    name: mq-service\n    weight: 100\n  port:\n    targetPort: mq-portal\n  tls:\n    termination: passthrough\n    insecureEdgeTerminationPolicy: Redirect\n  wildcardPolicy: None\n")),Object(r.b)("p",null,"You will want to connect to the container and run the setup commands as described in a previous scenario.  At this point, IBM MQ should be running and available on OpenShift."),Object(r.b)("p",null,"To run the Kafka Connect MQ Sink on OpenShift or any container platform, you will need to build a container that has Kafka installed as well as the MQ Sink and proper configuration.  Typically we would use the Strimzi containerized Kafka solution to run on OpenShift, but in this case to illustrate all the components we are building a container from scratch.  The following is the Dockerfile:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-Dockerfile"}),'FROM ubuntu:20.04\n\nADD https://mirrors.koehn.com/apache/kafka/2.5.0/kafka_2.12-2.5.0.tgz /tmp/\n\nRUN apt update                                                                                                     && \\\n    apt install -y curl git maven                                                                                  && \\\n    tar -C /opt -xvf /tmp/kafka_2.12-2.5.0.tgz                                                                     && \\\n    rm -f /tmp/kafka_2.12-2.5.0.tgz                                                                                && \\\n    ln -s /opt/kafka_2.12-2.5.0 /opt/kafka                                                                         && \\\n    mv -f /opt/kafka/config/connect-distributed.properties /opt/kafka/config/connect-distributed.properties.bak    && \\\n    cd /opt                                                                                                        && \\\n    git clone https://github.com/ibm-messaging/kafka-connect-mq-sink.git                                           && \\\n    cd /opt/kafka-connect-mq-sink                                                                                  && \\\n    mvn clean package                                                                                              && \\\n    ln -s /opt/kafka-connect-mq-sink/target/kafka-connect-mq-sink-1.3.0-jar-with-dependencies.jar /opt/kafka/libs/ && \\\n    mv -f /opt/kafka-connect-mq-sink/config/mq-sink.json /opt/kafka-connect-mq-sink/config/mq-sink.json.bak\n\nCOPY connect-distributed.properties /opt/kafka/config/connect-distributed.properties\nCOPY mq-sink-connector-config.json /opt/kafka-connect-mq-sink/config/mq-sink.json\nCOPY entrypoint.sh /entrypoint.sh\n\nENTRYPOINT ["/entrypoint.sh"]\n')),Object(r.b)("p",null,"We start with a vanilla Linux container, install the binary distribution of Kafka for Linux, clone the MQ Sink repository from Github, build the MQ Sink, and finally copy in some template files.  Finally the container runs a custom entrypoint script as shown below:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'#!/bin/sh\n\nset -x\n\nsed -i "s/KAFKA_BOOTSTRAP_SERVERS/${KAFKA_BOOTSTRAP_SERVERS}/g" /opt/kafka/config/connect-distributed.properties\nsed -i "s/KAFKA_API_KEY/${KAFKA_API_KEY}/g"                     /opt/kafka/config/connect-distributed.properties\n\n\nsed -i "s/KAFKA_TOPICS/${KAFKA_TOPICS}/g"         /opt/kafka-connect-mq-sink/config/mq-sink.json\nsed -i "s/MQ_QUEUE_MANAGER/${MQ_QUEUE_MANAGER}/g" /opt/kafka-connect-mq-sink/config/mq-sink.json\nsed -i "s/MQ_HOST/${MQ_HOST}/g"                   /opt/kafka-connect-mq-sink/config/mq-sink.json\nsed -i "s/MQ_PORT/${MQ_PORT}/g"                   /opt/kafka-connect-mq-sink/config/mq-sink.json\nsed -i "s/MQ_USER/${MQ_USER}/g"                   /opt/kafka-connect-mq-sink/config/mq-sink.json\nsed -i "s/MQ_PASSWORD/${MQ_PASSWORD}/g"           /opt/kafka-connect-mq-sink/config/mq-sink.json\nsed -i "s/MQ_CHANNEL/${MQ_CHANNEL}/g"             /opt/kafka-connect-mq-sink/config/mq-sink.json\nsed -i "s/MQ_QUEUE/${MQ_QUEUE}/g"                 /opt/kafka-connect-mq-sink/config/mq-sink.json\n\n/opt/kafka/bin/connect-distributed.sh /opt/kafka/config/connect-distributed.properties &\n\nsleep 60\ncurl -X DELETE -H "Content-Type: application/json" http://localhost:8083/connectors/mq-sink-connector\ncurl -X POST -H "Content-Type: application/json" http://localhost:8083/connectors --data "@/opt/kafka-connect-mq-sink/config/mq-sink.json"\n\ntail -f /dev/null\n')),Object(r.b)("p",null,"Again this is not a production-ready entrypoint container script; it’s intended for POC purposes.  The script updates the template files copied into the container with values from the environment (either ",Object(r.b)("inlineCode",{parentName:"p"},"--env")," using Docker, or from a ",Object(r.b)("inlineCode",{parentName:"p"},"ConfigMap")," in OpenShift) and then starts Kafka Connect in distributed mode.  It pauses the script for 1 minute to let Kafka Connect start, then finally activates the MQ Sink by POSTing the MQ Sink configuration using ",Object(r.b)("inlineCode",{parentName:"p"},"cURL"),"."),Object(r.b)("p",null,"The two template configuration files that are copied into the container are shown below."),Object(r.b)("h3",null,"connect-distributed.properties:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'# A list of host/port pairs to use for establishing the initial connection to the Kafka cluster.\nbootstrap.servers=KAFKA_BOOTSTRAP_SERVERS\nssl.enabled.protocols=TLSv1.2\nssl.protocol=TLS\nsecurity.protocol=SASL_SSL\nsasl.mechanism=PLAIN\nsasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="token" password="KAFKA_API_KEY";\n\n# Consumer side configuration\nconsumer.bootstrap.servers=KAFKA_BOOTSTRAP_SERVERS\nconsumer.security.protocol=SASL_SSL\nconsumer.ssl.protocol=TLSv1.2\nconsumer.sasl.mechanism=PLAIN\nconsumer.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="token" password="KAFKA_API_KEY";\n\n# Producer Side\nproducer.bootstrap.servers=KAFKA_BOOTSTRAP_SERVERS\nproducer.security.protocol=SASL_SSL\nproducer.ssl.protocol=TLSv1.2\nproducer.sasl.mechanism=PLAIN\nproducer.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="token" password="KAFKA_API_KEY";\n\nplugin.path=/opt/kafka/libs\n\n# unique name for the cluster, used in forming the Connect cluster group. Note that this must not conflict with consumer group IDs\ngroup.id=mq-sink-cluster\n\n# The converters specify the format of data in Kafka and how to translate it into Connect data. Every Connect user will\n# need to configure these based on the format they want their data in when loaded from or stored into Kafka\nkey.converter=org.apache.kafka.connect.json.JsonConverter\nvalue.converter=org.apache.kafka.connect.json.JsonConverter\n# Converter-specific settings can be passed in by prefixing the Converter\'s setting with the converter we want to apply\n# it to\nkey.converter.schemas.enable=true\nvalue.converter.schemas.enable=true\n\n# Topic to use for storing offsets. This topic should have many partitions and be replicated and compacted.\n# Kafka Connect will attempt to create the topic automatically when needed, but you can always manually create\n# the topic before starting Kafka Connect if a specific topic configuration is needed.\n# Most users will want to use the built-in default replication factor of 3 or in some cases even specify a larger value.\n# Since this means there must be at least as many brokers as the maximum replication factor used, we\'d like to be able\n# to run this example on a single-broker cluster and so here we instead set the replication factor to 1.\noffset.storage.topic=connect-offsets\noffset.storage.replication.factor=3\n#offset.storage.partitions=25\n\n# Topic to use for storing connector and task configurations; note that this should be a single partition, highly replicated,\n# and compacted topic. Kafka Connect will attempt to create the topic automatically when needed, but you can always manually create\n# the topic before starting Kafka Connect if a specific topic configuration is needed.\n# Most users will want to use the built-in default replication factor of 3 or in some cases even specify a larger value.\n# Since this means there must be at least as many brokers as the maximum replication factor used, we\'d like to be able\n# to run this example on a single-broker cluster and so here we instead set the replication factor to 1.\nconfig.storage.topic=connect-configs\nconfig.storage.replication.factor=3\n\n# Topic to use for storing statuses. This topic can have multiple partitions and should be replicated and compacted.\n# Kafka Connect will attempt to create the topic automatically when needed, but you can always manually create\n# the topic before starting Kafka Connect if a specific topic configuration is needed.\n# Most users will want to use the built-in default replication factor of 3 or in some cases even specify a larger value.\n# Since this means there must be at least as many brokers as the maximum replication factor used, we\'d like to be able\n# to run this example on a single-broker cluster and so here we instead set the replication factor to 1.\nstatus.storage.topic=connect-status\nstatus.storage.replication.factor=3\n\n#status.storage.partitions=5\n\n# Flush much faster than normal, which is useful for testing/debugging\noffset.flush.interval.ms=10000\n')),Object(r.b)("h3",null,"mq-sink-connector-config.json:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n  "name": "mq-sink-connector",\n  "config":\n  {\n      "connector.class": "com.ibm.eventstreams.connect.mqsink.MQSinkConnector",\n      "tasks.max": "1",\n      "topics": "KAFKA_TOPICS",\n\n      "key.converter": "org.apache.kafka.connect.storage.StringConverter",\n      "value.converter": "org.apache.kafka.connect.storage.StringConverter",\n\n      "mq.queue.manager": "MQ_QUEUE_MANAGER",\n      "mq.connection.name.list": "MQ_HOST(MQ_PORT)",\n      "mq.user.name": "MQ_USER",\n      "mq.password": "MQ_PASSWORD",\n      "mq.user.authentication.mqcsp": true,\n      "mq.channel.name": "MQ_CHANNEL",\n      "mq.queue": "MQ_QUEUE",\n      "mq.message.builder": "com.ibm.eventstreams.connect.mqsink.builders.DefaultMessageBuilder"\n  }\n}\n')),Object(r.b)("p",null,"Notice in these two files there are several capitalized variables which are replaced by the entrypoint.sh script at container startup."),Object(r.b)("p",null,"To deploy the container on OpenShift, we create a ",Object(r.b)("inlineCode",{parentName:"p"},"ConfigMap")," with information about the IBM EventStreams on IBM Cloud instance as well as the local instance of MQ on OpenShift."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'kind: ConfigMap\napiVersion: v1\nmetadata:\n  name: mq-kafka-sink-demo-config\n  namespace: mq-demo\ndata:\n  KAFKA_API_KEY: bA ... Qp\n  KAFKA_BOOTSTRAP_SERVERS: >-\n    broker-1- ... eventstreams.cloud.ibm.com:9093,broker-0- ... eventstreams.cloud.ibm.com:9093,broker-4- ... eventstreams.cloud.ibm.com:9093,broker-2- ... eventstreams.cloud.ibm.com:9093,broker-5- ... eventstreams.cloud.ibm.com:9093,broker-3- ... eventstreams.cloud.ibm.com:9093\n  KAFKA_TOPICS: inventory\n  MQ_HOST: mq-service\n  MQ_PORT: "1414"\n  MQ_USER: admin\n  MQ_QUEUE_MANAGER: QM1\n  MQ_PASSWORD: passw0rd\n  MQ_CHANNEL: KAFKA.CHANNEL\n  MQ_QUEUE: INVENTORY\n')),Object(r.b)("p",null,"Finally to deploy the MQ Sink container, we create a Pod definition on OpenShift:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: v1\nkind: Pod\nmetadata:\n  name: mq-kafka-sink-demo\n  labels:\n    app: mq-kafka-sink-demo-app\n  namespace: mq-demo\nspec:\n  containers:\n    - name: mq-kafka-sink-demo\n      image: registry/mq-kafka-sink-demo:0.0.1\n      envFrom:\n        - configMapRef:\n            name: mq-kafka-sink-demo-config\n")),Object(r.b)("p",null,"With the correct credentials for IBM EventStreams and IBM MQ, Kafka Connect should connect to both services and pull data from the EventStreams topic configured to the MQ Queue configured.  You will see signs of success in the container output (via oc logs, or in the UI):"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'+ curl -X POST -H Content-Type: application/json http://localhost:8083/connectors --data @/opt/kafka-connect-mq-sink/config/mq-sink.json\n...\n{"name":"mq-sink-connector","config":{"connector.class":"com.ibm.eventstreams.connect.mqsink.MQSinkConnector","tasks.max":"1","topics":"inventory","key.converter":"org.apache.kafka.connect.storage.StringConverter","value.converter":"org.apache.kafka.connect.storage.StringConverter","mq.queue.manager":"QM1","mq.connection.name.list":"mq-service(1414)","mq.user.name":"admin","mq.password":"passw0rd","mq.user.authentication.mqcsp":"true","mq.channel.name":"KAFKA.CHANNEL","mq.queue":"INVENTORY","mq.message.builder":"com.ibm.eventstreams.connect.mqsink.builders.DefaultMessageBuilder","name":"mq-sink-connector"},"tasks":[{"connector":"mq-sink-connector","task":0}],"type":"sink"}\n...\n[2020-06-23 04:26:26,054] INFO Creating task mq-sink-connector-0 (org.apache.kafka.connect.runtime.Worker:419)\n...[2020-06-23 04:26:26,449] INFO Connection to MQ established (com.ibm.eventstreams.connect.mqsink.JMSWriter:229)\n[2020-06-23 04:26:26,449] INFO WorkerSinkTask{id=mq-sink-connector-0} Sink task finished initialization and start (org.apache.kafka.connect.runtime.WorkerSinkTask:306)\n')),Object(r.b)("p",null,"You should now have the Kafka Connector MQ Sink running on OpenShift."),Object(r.b)("h2",null,"Scenario 3: Rabbitmq on premise to Event Streams on Cloud via RabbitMQ connector source"),Object(r.b)("p",null,"In this scenario we are using the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/ibm-messaging/kafka-connect-rabbitmq-source"}),"IBM messaging github: source connector for RabbitMQ"),". The configuration for this connector is also done using Json config file, with a POST to the Kafka connectors URL."),Object(r.b)("p",null,"The ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jbcodeforce/eda-kconnect-lab"}),"lab repository")," includes a docker compose file (",Object(r.b)("inlineCode",{parentName:"p"},"RabbitMQ-Kconnect-compose.yaml"),") under the ",Object(r.b)("inlineCode",{parentName:"p"},"infrastructure")," folder to run Rabbit MQ and Kconnect together on your local computer."),Object(r.b)("p",null,"In scenario 1, we were using the official IBM MQ Connector docker image, but in this scenario we have to define a Kafka connect image that includes the RabbitMQ and JDBC connectors. Which means we needs to get the different connector jar files, and build a docker image. Those steps were described in ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#scenario-setup"}),"previous section"),"."),Object(r.b)("h3",null,"Pre-requisites"),Object(r.b)("p",null,"To send message to RabbitMQ, we have implemented a simple simulator, to send item sale messages for one of the stores. The code is under ",Object(r.b)("inlineCode",{parentName:"p"},"store-sale-producer")," folder and we have also uploaded the image into dockerhub. If you need to rebuild the image the following commands may be done:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"./mvnw clean package -Dquarkus.container-image.build=true -Dquarkus.container-image.group=ibmcase -Dquarkus.container-image.tag=1.0.0\n")),Object(r.b)("h3",null,"Start the backend environment"),Object(r.b)("p",null,"In this section we start RabbitMQ, Kafka Connect and the Store Item Sale generator app. This app exposes a REST api to generate items sale operations that happen in a predefined set of stores."),Object(r.b)("p",null,"Under the infrastructure folder use the command: ",Object(r.b)("inlineCode",{parentName:"p"},"docker-compose -f RabbitMQ-Kconnect-compose.yaml up"),"."),Object(r.b)("p",null,"The trace includes RabbitMQ, storeSaleGenerator_1 and Kafka connect logs. Here is a small extract of important messages:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"rabbitmq_1            | 2020-06-17 06:12:58.293 [info] <0.9.0> Server startup complete; 4 plugins started.\nrabbitmq_1            |  * rabbitmq_management\nrabbitmq_1            |  * rabbitmq_web_dispatch\nrabbitmq_1            |  * rabbitmq_management_agent\nrabbitmq_1            |  * rabbitmq_amqp1_0\nrabbitmq_1            |  completed with 4 plugins.\n....\nstoreSaleGenerator_1  | 2020-06-17 06:12:44,056 INFO  [io.quarkus] (main) Profile prod activated.\nstoreSaleGenerator_1  | 2020-06-17 06:12:44,057 INFO  [io.quarkus] (main) Installed features: [cdi, mutiny, resteasy, resteasy-jsonb, smallrye-openapi, smallrye-reactive-messaging, smallrye-reactive-messaging-amqp, vertx]\n")),Object(r.b)("h3",null,"Verify the RabbitMQ settings"),Object(r.b)("p",null,"In a Web Browser go to ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://localhost:1567/"}),"http://localhost:1567/")," using the guest/guest login."),Object(r.b)("p",null,"You should reach this console:"),Object(r.b)("img",{src:"./images/rabbitmq-overview.png",alt:"7"}),Object(r.b)("p",null,"If in the Admin tab you do not see ",Object(r.b)("strong",{parentName:"p"},"rabbit-user")," listed do the following:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Add a new admin user: ",Object(r.b)("strong",{parentName:"li"},"rabbit-user/rabbit-pass")," using the Admin tab. Enable the virtual host to be ’/‘.")),Object(r.b)("img",{src:"./images/rabbitmq-user.png",alt:null}),Object(r.b)("p",null,"Go to the Queue tab and add ",Object(r.b)("inlineCode",{parentName:"p"},"items")," queue with default parameters:"),Object(r.b)("img",{src:"./images/rabbitmq-item-queue.png",alt:"8"}),Object(r.b)("p",null,"With the following result"),Object(r.b)("img",{src:"./images/rabbitmq-item-queue-2.png",alt:"9"}),Object(r.b)("h3",null,"Configure the kafka connector for Rabbitmq source"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"rabbitmq-source.json")," define the connector and the RabbitMQ connection parameters:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n    "name": "RabbitMQSourceConnector",\n    "config": {\n        "connector.class": "com.ibm.eventstreams.connect.rabbitmqsource.RabbitMQSourceConnector",\n        "tasks.max": "1",\n        "kafka.topic" : "items",\n        "rabbitmq.host": "rabbitmq",\n        "rabbitmq.queue" : "items",\n        "rabbitmq.prefetch.count" : "500",\n        "rabbitmq.automatic.recovery.enabled" : "true",\n        "rabbitmq.network.recovery.interval.ms" : "10000",\n        "rabbitmq.topology.recovery.enabled" : "true"\n    }\n}\n')),Object(r.b)("p",null,"This file is uploaded to Kafka Connect via a PORT operation:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'curl -X POST -H "Content-Type: application/json" http://localhost:8083/connectors   --data "@./rabbitmq-source.json"\n')),Object(r.b)("p",null,"To verify use: ",Object(r.b)("inlineCode",{parentName:"p"},"curl -X GET http://localhost:8083/connectors"),"."),Object(r.b)("p",null,"In Kafka connect trace you should see:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"[Worker clientId=connect-1, groupId=eda-kconnect] Connector RabbitMQSourceConnector config updated\n...\nStarting connector RabbitMQSourceConnector\n...\n Starting task RabbitMQSourceConnector-0\n\n")),Object(r.b)("p",null,"And Rabbitmq that get the connection from Kafka Connect."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"rabbitmq_1  [info] <0.1766.0> accepting AMQP connection <0.1766.0> (172.19.0.3:33040 -> 172.19.0.2:5672)\nkconnect_1  INFO Creating Channel (com.ibm.eventstreams.connect.rabbitmqsource.RabbitMQSourceTask:61)\nrabbitmq_1  connection <0.1766.0> (172.19.0.3:33040 -> 172.19.0.2:5672): user 'rabbit-user' authenticated and granted access to vhost '/'\n")),Object(r.b)("h3",null,"Generate sale messages"),Object(r.b)("p",null,"The Store application has an OpenAPI ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://localhost:8080/swagger-ui/"}),"http://localhost:8080/swagger-ui/")," definition to send messages:  ",Object(r.b)("inlineCode",{parentName:"p"},"/stores/start/2")," api:"),Object(r.b)("img",{src:"./images/store-app-1.png",alt:"5"}),Object(r.b)("p",null,"Or use ",Object(r.b)("inlineCode",{parentName:"p"},"curl -X POST http://localhost:8080/stores/start/2")),Object(r.b)("p",null,"In the trace you should see something like:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'storeSaleGenerator_1  INFO  [ibm.gse.eda.sto.inf.ItemSaleGenerator] (executor-thread-1) {"id":0,"storeName":"SF02","itemCode":"IT07","quantity":7,"price":46.79320631709398}\nstoreSaleGenerator_1  INFO  [ibm.gse.eda.sto.inf.ItemSaleGenerator] (executor-thread-1) {"id":1,"storeName":"NYC01","itemCode":"IT00","quantity":7,"price":0.7764381649099172}\n')),Object(r.b)("h3",null,"Verify messages arrived in Kafka items topic"),Object(r.b)("p",null,"We can use the Kafdrop tool to go to the ",Object(r.b)("inlineCode",{parentName:"p"},"items")," topic as illustrated below. The tool can be started via the ",Object(r.b)("inlineCode",{parentName:"p"},"./startKafdrop.sh")," command under the ",Object(r.b)("inlineCode",{parentName:"p"},"infrastructure")," folder after setting a ",Object(r.b)("inlineCode",{parentName:"p"},"kakfa.properties")," file as:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-properties"}),'security.protocol=SASL_SSL\nssl.protocol=TLSv1.2\nssl.enabled.protocols=TLSv1.2\nssl.endpoint.identification.algorithm=HTTPS\nsasl.mechanism=PLAIN\nsasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="token" password="APIKEY";\n')),Object(r.b)("img",{src:"./images/kafdrop.png",alt:null}),Object(r.b)("h2",null,"Scenario 4: Event Streams on Cloud to DB2 on premise via JDBC Sink connector"),Object(r.b)("p",null,"This scenario is using the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/ibm-messaging/kafka-connect-jdbc-sink"}),"IBM Kafka Connect sink connector for JDBC")," to get data from the ",Object(r.b)("inlineCode",{parentName:"p"},"inventory topic")," and write records to the ",Object(r.b)("inlineCode",{parentName:"p"},"inventory")," table in DB2. This lab explain the definition of the connector and how to run an integration test that sends data to the inventory topic."),Object(r.b)("h3",null,"Pre-requisites"),Object(r.b)("p",null,"As a pre-requisite you need to have a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://cloud.ibm.com/docs/Db2onCloud?topic=Db2onCloud-getting-started"}),"DB2 instance on cloud")," up and running with defined credentials. From the credentials you need the username, password and the ",Object(r.b)("inlineCode",{parentName:"p"},"ssljdbcurl")," parameter. Something like “jdbc:db2://dashdb-tx…net:50001/BLUDB:sslConnection=true;“."),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Build and deploy the ",Object(r.b)("inlineCode",{parentName:"p"},"inventory-app"),". This application is a simple Java microprofile 3.3 app exposing a set of end points for cRUD operations on stores, items and inventory. It is based on ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https:quarkus.io"}),"Quarkus"),". The instructions to build, and deploy this app is in the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jbcodeforce/eda-kconnect-lab/tree/master/inventory-app"}),"README")," under the ",Object(r.b)("inlineCode",{parentName:"p"},"inventory-app")," folder of ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jbcodeforce/eda-kconnect-lab"}),"this repository"),". At the application starts stores and items records are uploaded to the database.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Verify the stores and items records are loaded"))),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"If you deploy the ",Object(r.b)("inlineCode",{parentName:"p"},"inventory-app")," from previous step, then you will have the database created and populated with some stores and items automatically. If you want to drop the data use ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://raw.githubusercontent.com/jbcodeforce/eda-kconnect-lab/master/inventory-app/src/main/resources/drop.sql"}),"the drop sql script")," and then reload them the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://raw.githubusercontent.com/jbcodeforce/eda-kconnect-lab/master/inventory-app/src/main/resources/import.sql"}),"insert sql script")," from ",Object(r.b)("inlineCode",{parentName:"p"},"inventory-app/src/main/resources")," folder. For that you can use the ",Object(r.b)("inlineCode",{parentName:"p"},"Run sql")," menu in the DB2 console:"),Object(r.b)("img",Object(a.a)({parentName:"li"},{src:"./images/db2-1.png",alt:"DB1"})),Object(r.b)("p",{parentName:"li"},"Select the database schema matching the username used as credential, and then open the SQL editor:"),Object(r.b)("img",Object(a.a)({parentName:"li"},{src:"./images/db2-2.png",alt:"DB2"})),Object(r.b)("p",{parentName:"li"},"Verify the items with ",Object(r.b)("inlineCode",{parentName:"p"},"select * from items;")),Object(r.b)("p",{parentName:"li"}," ",Object(r.b)("img",Object(a.a)({parentName:"p"},{src:"./images/db2-3.png",alt:"DB2"}))),Object(r.b)("p",{parentName:"li"},"Verify the stores with ",Object(r.b)("inlineCode",{parentName:"p"},"select * from stores;")),Object(r.b)("img",Object(a.a)({parentName:"li"},{src:"./images/db2-4.png",alt:"DB2"})),Object(r.b)("p",{parentName:"li"},"The inventory has one record to illustrate the relationship between store, item and inventory."))),Object(r.b)("h3",null,"Run the Kafka Connector in distributed mode"),Object(r.b)("p",null,"The docker image built in the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#scenario-setup"}),"setup")," has the configuration for kafka connect distributed cluster, we need in this scenario to start the connector and upload the DB2 Sink connector definition. To start it, run the script ",Object(r.b)("inlineCode",{parentName:"p"},"./createOrStartKconnect.sh start")," under ",Object(r.b)("inlineCode",{parentName:"p"},"kconnect")," folder."),Object(r.b)("h3",null,"Upload the DB2 sink definition"),Object(r.b)("p",null,"Rename the file ",Object(r.b)("inlineCode",{parentName:"p"},"db2-sink-config-TMPL.json")," as ",Object(r.b)("inlineCode",{parentName:"p"},"db2-sink-config.json")," and modify the DB2 server URL, DB2 username and password. The DB schema matches the user name, so update this setting for the ",Object(r.b)("inlineCode",{parentName:"p"},"table.name.format"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'  "name": "jdbc-sink-connector",\n  "config": {\n    "connector.class": "com.ibm.eventstreams.connect.jdbcsink.JDBCSinkConnector",\n    "tasks.max": "1",\n    "topics": "inventory",\n    "connection.url": "jdbc:db2://....services.dal.bluemix.net:50001/BLUDB:sslConnection=true;",\n    "connection.user": "<username>",\n    "connection.password": "<password>",\n    "connection.ds.pool.size": "1",\n    "insert.mode.databaselevel": "true",\n    "table.name.format": "<username>.INVENTORY"\n  }\n')),Object(r.b)("p",null,"Once done, you can run the ",Object(r.b)("inlineCode",{parentName:"p"},"./sendJdbcSinkConfig.sh url-kafka-connect")," to upload the above definition to the Kafka connect controller. When running locally the command is ",Object(r.b)("inlineCode",{parentName:"p"},"./sendJdbcSinkConfig.sh localhodt:8083"),". This script delete previously define connector with the same name, and then perform a POST operation on the ",Object(r.b)("inlineCode",{parentName:"p"},"/connectors")," end point."),Object(r.b)("p",null,"The connector trace should have something like:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-logs"}),"connector.class = com.ibm.eventstreams.connect.jdbcsink.JDBCSinkConnector\n    errors.log.enable = false\n    errors.log.include.messages = false\n    errors.retry.delay.max.ms = 60000\n    errors.retry.timeout = 0\n    errors.tolerance = none\n    header.converter = null\n    key.converter = null\n    name = jdbc-sink-connector\n    tasks.max = 1\n    transforms = []\n    value.converter = null\n\n")),Object(r.b)("h3",null,"Generate some records"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"integration-tests")," folder includes a set of python code to load some records to the expected topic."),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Start a python environment with ",Object(r.b)("inlineCode",{parentName:"li"},"./startPython.sh")),Object(r.b)("li",{parentName:"ol"},"Within the bash, start python to execute the  ",Object(r.b)("inlineCode",{parentName:"li"},"ProduceInventoryEvent.py")," script, and specify the number of records to send via the —size argument.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"python ProduceInventoryEvent.py --size 2\n")),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"The trace should have something like")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"Produce to the topic inventory\n[KafkaProducer] - This is the configuration for the producer:\n[KafkaProducer] - {'bootstrap.servers': 'broker-0-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-1-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-2-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-3-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-4-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-5-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093', 'group.id': 'ProducerInventory', 'acks': 0, 'request.timeout.ms': 10000, 'security.protocol': 'SASL_SSL', 'sasl.mechanisms': 'PLAIN', 'sasl.username': 'token', 'sasl.password': 'am_rbb9e794mMwhE-KGPYo0hhW3h91e28OhT8IlruFe5'}\nsending -> {'storeName': 'LA02', 'itemCode': 'IT09', 'id': 0, 'timestamp': 1591211295.617515}\n[KafkaProducer] - Message delivered to inventory [0]\nsending -> {'storeName': 'PT02', 'itemCode': 'IT00', 'id': 1, 'timestamp': 1591211296.7727954}\n[KafkaProducer] - Message delivered to inventory [0]\n\n")),Object(r.b)("h3",null,"Verify records are uploaded into the Inventory database"),Object(r.b)("p",null,"Using the DB2 console, use the ",Object(r.b)("inlineCode",{parentName:"p"},"select * from inventory;")," SQL query to get the last records."),Object(r.b)("h2",null,"Scenario 5: Run the solution components end to end on Kubernetes"),Object(r.b)("p",null,"This solution covers all the components of the data pipeline. It still uses DB2 and Event Streams on Cloud but deploy all the other component in OpenShift as part of IBM Kubernetes Service."),Object(r.b)("h3",null,"Pre-requisites"),Object(r.b)("p",null,"Create the following services in IBM Cloud:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://cloud.ibm.com/docs/Db2onCloud?topic=Db2onCloud-getting-started"}),"DB2 instance"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://cloud.ibm.com/docs/containers?topic=containers-cs_cluster_tutorial#cs_cluster_tutorial"}),"IBM Kubernetes Service"),".")),Object(r.b)("h3",null,"Deployment"),Object(r.b)("p",null,"To be finished !"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Verify the Store Sale Simulator runs"),Object(r.b)("li",{parentName:"ol"},"Verify the connectors ",Object(r.b)("inlineCode",{parentName:"li"},"http://localhost:8083/connectors"))))}d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-technology-event-streams-kconnect-mdx-7a2ec7048cbc65a7d111.js.map