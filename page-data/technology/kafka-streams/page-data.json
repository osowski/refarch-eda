{"componentChunkName":"component---src-pages-technology-kafka-streams-index-mdx","path":"/technology/kafka-streams/","result":{"pageContext":{"frontmatter":{"title":"Kafka Streams","description":"Kafka Streams"},"relativePagePath":"/technology/kafka-streams/index.mdx","titleType":"append","MdxNode":{"id":"12cdf619-e405-5f25-808f-5b6c26ec35ff","children":[],"parent":"dcece103-e0b7-5f6a-8399-17e77e88f495","internal":{"content":"---\ntitle: Kafka Streams\ndescription: Kafka Streams\n---\n\nKafka Streams is a graph of processing nodes to implement the logic to process event streams. Each node process events from the parent node. We recommend reading this excellent introduction [Kafka stream made simple](https://www.confluent.io/blog/introducing-kafka-streams-stream-processing-made-simple/) from Jay Kreps from Confluent to get a good understanding of why Kafka stream was created.\n\nTo summarize, **Kafka Stream** has the following capabilities:\n\n* Stream processing is helpful for handling out-of-order data, *reprocessing* input as code changes, and performing stateful computations. It uses producer / consumer APIs, stateful storage and consumer groups. It treats both past and future data the same way.\n* This is an embedded library to integrate in your application.\n* Integrate tables for state persistence combined streams of events.\n* Consumes continuous real time flows of records and publishes new flows.\n* Can scale vertically, by increasing the number of threads for each Kafka Streams application on a single machine, or horizontally by adding an additional machine with the same `application.id`.\n* Supports exactly-once processing semantics to guarantee that each record will be processed once and only once even when there is a failure.\n* Stream APIs transform, aggregate and enrich data, per record with milli second latency, from one topic to another one.\n* Supports stateful and windowing operations by processing one record at a time.\n* Can be integrated in java application. No need for separate processing cluster. It is a Java API. But a Stream app is executed outside of the broker code, which is different than message flow in an ESB.\n* Elastic, highly scalable, fault tolerance, it can recover from failure.\n\n![](../images/kafka-stream-arch.png)\n\n* An application's processor topology is scaled by breaking it into multiple tasks.\n* Tasks can then instantiate their own processor topology based on the assigned partitions.\n\nIn general the code for processing event does the following:\n\n* Set a properties object to specify which brokers to connect to and what kind of serialization to use.\n* Define a stream client: if you want to get the stream of records use **KStream**, if you want a changelog with the last value of a given, key use **KTable** (Example of using KTable is to keep a user profile with userid as key).\n* Create a topology of input source and sink target and the set of actions to perform in between.\n* Start the stream client to consume records.\n\nProgramming with KStream and Ktable is not easy at first, as there are a lot of concepts for data manipulations, serialization and operations chaining.\n\nA stateful operator uses the streaming Domain Specific Language, with constructs for aggregation, join and time window operations. Stateful transformations require a state store associated with the stream processor.\n\n## Simple example\n\nThe code below comes from Kafka examples and is counting word occurrence in text:\n\n```java\nfinal StreamsBuilder builder = new StreamsBuilder();\n// pattern to extract word\nfinal Pattern pattern = Pattern.compile(\"\\\\W+\");\n// source is a kafka topic\nKStream<String, String> textLines = builder.stream(source);\n\nKTable<String, Long> wordCounts = textLines\n    .flatMapValues(textLine -> Arrays.asList(pattern.split(textLine.toLowerCase())))\n    .print(Printed.toSysOut()\n    .groupBy((key, word) -> word)\n    .count(Materialized.<String, Long, KeyValueStore<Bytes, byte[]>>as(\"counts-store\"));\n// sink is another kafka topic. Produce for each word the number of occurrence in the given doc\nwordCounts.toStream().to(sink, Produced.with(Serdes.String(), Serdes.Long()));\n\nKafkaStreams streams = new KafkaStreams(builder.build(), props);\nstreams.start();\n```\n\n* [KStream](https://kafka.apache.org/25/javadoc/org/apache/kafka/streams/kstream/KStream.html) represents KeyValue records coming as event stream from the topic.\n* `flatMapValues()` transforms the value of each record in \"this\" stream into zero or more values with the same key in a new KStream (in memory). So here the text line is split into words. The parameter is a [ValueMapper](https://kafka.apache.org/25/javadoc/org/apache/kafka/streams/kstream/ValueMapper.html) which applies transformation on values but keeps the key. Another important transformation is the [KeyValueMapper](https://kafka.apache.org/25/javadoc/org/apache/kafka/streams/kstream/KeyValueMapper.html).\n* `groupBy()` Group the records of this KStream on a new key that is selected using the provided KeyValueMapper. So here it creates new KStream with the extracted word as key.\n* `count()` counts the number of records in this stream by the grouped key. `Materialized` is an class to define a \"store\" to persist state and data. So here the state store is \"counts-store\". As store is a in-memory table, but it could also be persisted in external database. Could be the Facebook's [RocksDB key value persistence](https://rocksdb.org/) or a log-compacted topic in Kafka.\n* Produced defines how to provide the optional parameter types when producing to new topics.\n* KTable is an abstraction of a changelog stream from a primary-keyed table.\n\nImportant: map, flatMapValues and mapValues ... functions don’t modify the object or value presented as a parameter.\n\nSee [this article from Confluent](https://docs.confluent.io/current/streams/architecture.html) for deeper kafka stream architecture presentation.\n\n### Example to run the Word Count application\n\n1. Be sure to create the needed different topics once the Kafka broker is started (test-topic, streams-wordcount-output):\n\n    ```shell\n    docker exec -ti Kafka /bin/bash\n    cd /scripts\n    ./createtopics.sh\n    ```\n\n1. Start a terminal window and execute the command to be ready to send message.\n\n    ```shell\n    $ docker exec -ti Kafka /bin/bash\n    # can use the /scripts/openProducer.sh or...\n    root> /opt/Kafka_2.11-0.10.1.0/bin/Kafka-console-producer.sh --broker-list localhost:9092 --topic streams-plaintext-input\n    ```\n\n1. Start another terminal to listen to the output topic:\n\n    ```shell\n    $ docker exec -ti Kafka /bin/bash\n    # can use the /scripts/consumeWordCount.sh or...\n    root> /opt/Kafka_2.11-0.10.1.0/bin/Kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic streams-wordcount-output --from-beginning --formatter Kafka.tools.DefaultMessageFormatter --property print.key=true --property print.value=true --property key.deserializer=org.apache.Kafka.common.serialization.StringDeserializer --property value.deserializer=org.apache.Kafka.common.serialization.LongDeserializer\n    ```\n\n1. Start the stream client to count word in the entered lines\n\n    ```shell\n    mvn exec:java -Dexec.mainClass=ibm.cte.Kafka.play.WordCount\n    ```\n\nOutputs of the WordCount application is actually a continuous stream of updates, where each output record is an updated count of a single word. A KTable is counting the occurrence of word, and a KStream send the output message with updated count.\n\n## Some other examples\n\n* Map values:\n\n```java\nKStream<String,String> simpleFirstStream =\n builder.stream(\"src-topic\", Consumed.with(Serdes.String(), Serdes.String()));\n          .mapValues(String::toUpperCase);\n          .to(\"out-topic\", Produced.with(Serdes.String(), Serdes.String()));\n```\n\n* Extract values from input to create other object: (Example from KStreams in Action book chapter 3)\n\n```java\nKStream<String, PurchasePattern> patternKStream =\n     purchaseKStream.mapValues(purchase -> PurchasePattern.builder(purchase).build());\n\npatternKStream.to(\"patterns\", Produced.with(Serdes.String(),new JSONSerde<Purchase>())));\n```\n\n* Map key by using KeyValueMapper: For example to filter low level transaction and generate a stream with a key = to a time:\n\n```java\nKeyValueMapper<String, Purchase, Long> purchaseDateAsKey = (key, purchase) -> purchase.getPurchaseDate().getTime();\n\nKStream<Long, Purchase> filteredKStream = purchaseKStream.filter((key, purchase) -> purchase.getPrice() > 5.00).selectKey(purchaseDateAsKey);\n```\n\n## Some design considerations\n\n* Partitions are assigned to a StreamTask, and each StreamTask has its own state store. So important to be sure to have key and kafka will assign records with same key to same partition so lookup inside state store will work.\n* Avoid external database lookup as part of the stream: As kafka can handle million of records per second, so a lookup to an external database to do a join between a primary key that is in the event and a table in the database to do a data enrichment, for example is a bad practice. The approach will be to use Ktable, with state store and perform a join in memory.\n\n### Join streams Examples\n\nWe recommend reading [this deep dive article](https://www.confluent.io/blog/crossing-streams-joins-apache-kafka/) on joining streams and stream with table. The important points from this article:\n\n* kstream - kstream joins are windowed to control the size of data to keep in memory to search for the matching records.\n\n## Faust: a python library to do kafka streaming\n\n[Faust](https://faust.readthedocs.io/en/latest/index.html) is a python library to support stream processing. It does not have its own DSL as Kafka streams in Java has, but just python functions.\n\nIt uses rocksdb to support tables.\n\nFor the installation, in your python environment do a `pipenv run pip install faust`, or `pip install faust`. Then use faust as a CLI. So to start an agent as worker use:\n\n```shell\nfaust -A nameofthepythoncode -l info\n```\n\nMultiple instances of a Faust worker can be started independently to distribute stream processing across machines and CPU cores.\n\n## Further reading\n\n* The API and [product documentation](https://kafka.apache.org/21/documentation/streams/developer-guide/).\n* [Deep dive explanation for the differences between KStream and KTable from Michael Noll](https://www.michael-noll.com/blog/2018/04/05/of-stream-and-tables-in-kafka-and-stream-processing-part1/)\n* [Distributed, Real-time Joins and Aggregations using Kafka Stream, from Michael Noll at Confluent](https://www.confluent.io/blog/distributed-real-time-joins-and-aggregations-on-user-activity-events-using-kafka-streams/)\n","type":"Mdx","contentDigest":"5f947f07ed2cfcff439dcdfc237f9b36","counter":339,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Kafka Streams","description":"Kafka Streams"},"exports":{},"rawBody":"---\ntitle: Kafka Streams\ndescription: Kafka Streams\n---\n\nKafka Streams is a graph of processing nodes to implement the logic to process event streams. Each node process events from the parent node. We recommend reading this excellent introduction [Kafka stream made simple](https://www.confluent.io/blog/introducing-kafka-streams-stream-processing-made-simple/) from Jay Kreps from Confluent to get a good understanding of why Kafka stream was created.\n\nTo summarize, **Kafka Stream** has the following capabilities:\n\n* Stream processing is helpful for handling out-of-order data, *reprocessing* input as code changes, and performing stateful computations. It uses producer / consumer APIs, stateful storage and consumer groups. It treats both past and future data the same way.\n* This is an embedded library to integrate in your application.\n* Integrate tables for state persistence combined streams of events.\n* Consumes continuous real time flows of records and publishes new flows.\n* Can scale vertically, by increasing the number of threads for each Kafka Streams application on a single machine, or horizontally by adding an additional machine with the same `application.id`.\n* Supports exactly-once processing semantics to guarantee that each record will be processed once and only once even when there is a failure.\n* Stream APIs transform, aggregate and enrich data, per record with milli second latency, from one topic to another one.\n* Supports stateful and windowing operations by processing one record at a time.\n* Can be integrated in java application. No need for separate processing cluster. It is a Java API. But a Stream app is executed outside of the broker code, which is different than message flow in an ESB.\n* Elastic, highly scalable, fault tolerance, it can recover from failure.\n\n![](../images/kafka-stream-arch.png)\n\n* An application's processor topology is scaled by breaking it into multiple tasks.\n* Tasks can then instantiate their own processor topology based on the assigned partitions.\n\nIn general the code for processing event does the following:\n\n* Set a properties object to specify which brokers to connect to and what kind of serialization to use.\n* Define a stream client: if you want to get the stream of records use **KStream**, if you want a changelog with the last value of a given, key use **KTable** (Example of using KTable is to keep a user profile with userid as key).\n* Create a topology of input source and sink target and the set of actions to perform in between.\n* Start the stream client to consume records.\n\nProgramming with KStream and Ktable is not easy at first, as there are a lot of concepts for data manipulations, serialization and operations chaining.\n\nA stateful operator uses the streaming Domain Specific Language, with constructs for aggregation, join and time window operations. Stateful transformations require a state store associated with the stream processor.\n\n## Simple example\n\nThe code below comes from Kafka examples and is counting word occurrence in text:\n\n```java\nfinal StreamsBuilder builder = new StreamsBuilder();\n// pattern to extract word\nfinal Pattern pattern = Pattern.compile(\"\\\\W+\");\n// source is a kafka topic\nKStream<String, String> textLines = builder.stream(source);\n\nKTable<String, Long> wordCounts = textLines\n    .flatMapValues(textLine -> Arrays.asList(pattern.split(textLine.toLowerCase())))\n    .print(Printed.toSysOut()\n    .groupBy((key, word) -> word)\n    .count(Materialized.<String, Long, KeyValueStore<Bytes, byte[]>>as(\"counts-store\"));\n// sink is another kafka topic. Produce for each word the number of occurrence in the given doc\nwordCounts.toStream().to(sink, Produced.with(Serdes.String(), Serdes.Long()));\n\nKafkaStreams streams = new KafkaStreams(builder.build(), props);\nstreams.start();\n```\n\n* [KStream](https://kafka.apache.org/25/javadoc/org/apache/kafka/streams/kstream/KStream.html) represents KeyValue records coming as event stream from the topic.\n* `flatMapValues()` transforms the value of each record in \"this\" stream into zero or more values with the same key in a new KStream (in memory). So here the text line is split into words. The parameter is a [ValueMapper](https://kafka.apache.org/25/javadoc/org/apache/kafka/streams/kstream/ValueMapper.html) which applies transformation on values but keeps the key. Another important transformation is the [KeyValueMapper](https://kafka.apache.org/25/javadoc/org/apache/kafka/streams/kstream/KeyValueMapper.html).\n* `groupBy()` Group the records of this KStream on a new key that is selected using the provided KeyValueMapper. So here it creates new KStream with the extracted word as key.\n* `count()` counts the number of records in this stream by the grouped key. `Materialized` is an class to define a \"store\" to persist state and data. So here the state store is \"counts-store\". As store is a in-memory table, but it could also be persisted in external database. Could be the Facebook's [RocksDB key value persistence](https://rocksdb.org/) or a log-compacted topic in Kafka.\n* Produced defines how to provide the optional parameter types when producing to new topics.\n* KTable is an abstraction of a changelog stream from a primary-keyed table.\n\nImportant: map, flatMapValues and mapValues ... functions don’t modify the object or value presented as a parameter.\n\nSee [this article from Confluent](https://docs.confluent.io/current/streams/architecture.html) for deeper kafka stream architecture presentation.\n\n### Example to run the Word Count application\n\n1. Be sure to create the needed different topics once the Kafka broker is started (test-topic, streams-wordcount-output):\n\n    ```shell\n    docker exec -ti Kafka /bin/bash\n    cd /scripts\n    ./createtopics.sh\n    ```\n\n1. Start a terminal window and execute the command to be ready to send message.\n\n    ```shell\n    $ docker exec -ti Kafka /bin/bash\n    # can use the /scripts/openProducer.sh or...\n    root> /opt/Kafka_2.11-0.10.1.0/bin/Kafka-console-producer.sh --broker-list localhost:9092 --topic streams-plaintext-input\n    ```\n\n1. Start another terminal to listen to the output topic:\n\n    ```shell\n    $ docker exec -ti Kafka /bin/bash\n    # can use the /scripts/consumeWordCount.sh or...\n    root> /opt/Kafka_2.11-0.10.1.0/bin/Kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic streams-wordcount-output --from-beginning --formatter Kafka.tools.DefaultMessageFormatter --property print.key=true --property print.value=true --property key.deserializer=org.apache.Kafka.common.serialization.StringDeserializer --property value.deserializer=org.apache.Kafka.common.serialization.LongDeserializer\n    ```\n\n1. Start the stream client to count word in the entered lines\n\n    ```shell\n    mvn exec:java -Dexec.mainClass=ibm.cte.Kafka.play.WordCount\n    ```\n\nOutputs of the WordCount application is actually a continuous stream of updates, where each output record is an updated count of a single word. A KTable is counting the occurrence of word, and a KStream send the output message with updated count.\n\n## Some other examples\n\n* Map values:\n\n```java\nKStream<String,String> simpleFirstStream =\n builder.stream(\"src-topic\", Consumed.with(Serdes.String(), Serdes.String()));\n          .mapValues(String::toUpperCase);\n          .to(\"out-topic\", Produced.with(Serdes.String(), Serdes.String()));\n```\n\n* Extract values from input to create other object: (Example from KStreams in Action book chapter 3)\n\n```java\nKStream<String, PurchasePattern> patternKStream =\n     purchaseKStream.mapValues(purchase -> PurchasePattern.builder(purchase).build());\n\npatternKStream.to(\"patterns\", Produced.with(Serdes.String(),new JSONSerde<Purchase>())));\n```\n\n* Map key by using KeyValueMapper: For example to filter low level transaction and generate a stream with a key = to a time:\n\n```java\nKeyValueMapper<String, Purchase, Long> purchaseDateAsKey = (key, purchase) -> purchase.getPurchaseDate().getTime();\n\nKStream<Long, Purchase> filteredKStream = purchaseKStream.filter((key, purchase) -> purchase.getPrice() > 5.00).selectKey(purchaseDateAsKey);\n```\n\n## Some design considerations\n\n* Partitions are assigned to a StreamTask, and each StreamTask has its own state store. So important to be sure to have key and kafka will assign records with same key to same partition so lookup inside state store will work.\n* Avoid external database lookup as part of the stream: As kafka can handle million of records per second, so a lookup to an external database to do a join between a primary key that is in the event and a table in the database to do a data enrichment, for example is a bad practice. The approach will be to use Ktable, with state store and perform a join in memory.\n\n### Join streams Examples\n\nWe recommend reading [this deep dive article](https://www.confluent.io/blog/crossing-streams-joins-apache-kafka/) on joining streams and stream with table. The important points from this article:\n\n* kstream - kstream joins are windowed to control the size of data to keep in memory to search for the matching records.\n\n## Faust: a python library to do kafka streaming\n\n[Faust](https://faust.readthedocs.io/en/latest/index.html) is a python library to support stream processing. It does not have its own DSL as Kafka streams in Java has, but just python functions.\n\nIt uses rocksdb to support tables.\n\nFor the installation, in your python environment do a `pipenv run pip install faust`, or `pip install faust`. Then use faust as a CLI. So to start an agent as worker use:\n\n```shell\nfaust -A nameofthepythoncode -l info\n```\n\nMultiple instances of a Faust worker can be started independently to distribute stream processing across machines and CPU cores.\n\n## Further reading\n\n* The API and [product documentation](https://kafka.apache.org/21/documentation/streams/developer-guide/).\n* [Deep dive explanation for the differences between KStream and KTable from Michael Noll](https://www.michael-noll.com/blog/2018/04/05/of-stream-and-tables-in-kafka-and-stream-processing-part1/)\n* [Distributed, Real-time Joins and Aggregations using Kafka Stream, from Michael Noll at Confluent](https://www.confluent.io/blog/distributed-real-time-joins-and-aggregations-on-user-activity-events-using-kafka-streams/)\n","fileAbsolutePath":"/home/runner/work/refarch-eda/refarch-eda/docs/src/pages/technology/kafka-streams/index.mdx"}}}}