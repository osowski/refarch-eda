{"componentChunkName":"component---src-pages-patterns-intro-index-mdx","path":"/patterns/intro/","result":{"pageContext":{"frontmatter":{"title":"Patterns in Event-Driven Architectures","description":"Understanding event driven microservice patterns"},"relativePagePath":"/patterns/intro/index.mdx","titleType":"append","MdxNode":{"id":"b1a3cc55-9443-5e96-9fd6-79347197feab","children":[],"parent":"2f57e1c1-69b9-5fef-9eb5-4752c3c41b7b","internal":{"content":"---\ntitle: Patterns in Event-Driven Architectures\ndescription: Understanding event driven microservice patterns\n---\n\n# Introduction\n\nIn this set of articles, we will detail some of the most import event-driven patterns that can be utilised during your event-driven microservice implementation.\n\nAdopting messaging (Pub/Sub) as a microservice communication approach involves using, at least, the following patterns:\n\n* [Decompose by subdomain](https://microservices.io/patterns/decomposition/decompose-by-subdomain.html): The domain-driven design approach is useful to identify and classify business\nfunctions and the corresponding microservices that would be associated with them. With the event storming method, aggregates help to find those subdomains of responsibility. (Source Chris Richardson - Microservices Patterns)\n* [Database per service](https://microservices.io/patterns/data/database-per-service.html): Each service persists data privately and is accessible only via its API.\nServices are loosely coupled limiting impact to other services when schema changes occur in the database. The chosen database technology is driven by business requirements. (Source Chris Richardson - Microservices Patterns)\nThe implementation of transactions that span multiple services is complex and enforces using the Saga pattern. Queries that span multiple entities are a challenge and CQRS represents an interesting solution.\n* [Strangler pattern](#strangler-pattern): Used to incrementally migrate an existing, monolithic, application by replacing a set of features to a microservice but keep both running in parallel.\nApplying a domain driven design approach, you may strangle the application using bounded context. But then as soon as this pattern is applied, you need to assess the co-existence between\nexisting bounded contexts and the new microservices. One of the challenges will be to define where the write and read operations occurs, and how data should be replicated between the contexts.\nThis is where event driven architecture helps.\n* [Event sourcing](/patterns/event-sourcing/): persists, to an append log, the states of a business entity, such as an Order, as a sequence of immutable state-changing events.\n* [Command Query Responsibility Segregation](/patterns/cqrs/): helps to separate queries from commands and help to address queries with cross-microservice boundary.\n* [Saga pattern:](/patterns/saga/) Microservices publish events when something happens in the scope of their control like an update in the business entities they are responsible for. A microservice, interested in other business entities, subscribes to those events and it can update its own state and business entities on receipt of these events. Business entity keys need to be unique and immutable.\n* [Event reprocessing with dead letter](/patterns/dlq/): event driven microservices may have to call external services via a synchronous call. We need to process failure in order to get response from those services using event backbone.\n* [Transactional outbox](#transactional-outbox): A service command typically needs to update the database and send messages/events.\nThe approach is to use an outbox table to keep the message to sent and a message relay process to publish events inserted into database to the event backbone. (Source Chris Richardson - Microservices Patterns)\n\n\n## Strangler pattern\n\n### Problem\n\nHow to migrate a monolithic application to a microservice based architecture without doing the huge effort of redeveloping the application from a blank slate. Replacing and rewriting an existing application can be a huge investment. Rewriting a subset of business functions while running current application in parallel may be relevant and reduce risk and velocity of changes.\n\nThe figure below illustrates a typical mainframe application, with external Java based user interface connected to the mainframe via iop/corba and with three different applications to manage product, order and customer.\n\n![1](./images/strangler.png)\n\n### Solution\n\nThe approach is to use a \"strangler\" interface to dispatch a request to new or old features. Existing features to migrate are selected by trying to isolate sub components.\n\nOne of main challenges is to isolate the data store and disover how the new microservices and the legacy application are accessing the shared data. Continuous data replication can be a solution to propagate write model to read model. Write model will most likely stays on the monolitic application, change data capture can be used, with event backbone to propagate change to read model.\n\nThe facade needs to be scalable and not a single point of failure. It needs to support new APIs (RESTful) and old API (most likely SOAP).\n\nThe following figure illustrates an implementation using an event driven solution with data replication to synchronize the write model to the read model on the mainframe.\n\n![2](./images/strangler-2.png)\n\n## Transactional outbox\n\nWhen distributed transaction is not supported by the messaging middleware (like current Kafka version), it is important to ensure consistency between the records in the database and the events published. In the reference implementation we used the approach to publish to the topic as soon as an order is received via the API and then the same code, is consuming this events to persist to the database. With this approach if write to the topic operation fails, the application can return an error to the user, if the write operation to the database fails, the code can reload from the non-committed record. \n\nBut there is another solution presented by the transactional outbox. For detailed information about this pattern see the documentation of the pattern in Chris Richardson's site: [Transactional outbox](https://microservices.io/patterns/data/transactional-outbox.html).\n\nTo summarize this pattern, the approach is to use an `outbox` table to keep the messages to sent and a message relay process to publish events inserted into database to the event backbone. In modern solution this relay is a change data capture agent. The following schema illustrates the approach:\n\n![3](./images/outbox.png)\n\nTo get a concrete example of this pattern we have developed a [deep dive lab](/use-cases/db2-debezium/) using Quarkus Debezium outbox pattern and a DB2 database.","type":"Mdx","contentDigest":"9d9ece602db848919a936bf3ebaead1d","owner":"gatsby-plugin-mdx","counter":714},"frontmatter":{"title":"Patterns in Event-Driven Architectures","description":"Understanding event driven microservice patterns"},"exports":{},"rawBody":"---\ntitle: Patterns in Event-Driven Architectures\ndescription: Understanding event driven microservice patterns\n---\n\n# Introduction\n\nIn this set of articles, we will detail some of the most import event-driven patterns that can be utilised during your event-driven microservice implementation.\n\nAdopting messaging (Pub/Sub) as a microservice communication approach involves using, at least, the following patterns:\n\n* [Decompose by subdomain](https://microservices.io/patterns/decomposition/decompose-by-subdomain.html): The domain-driven design approach is useful to identify and classify business\nfunctions and the corresponding microservices that would be associated with them. With the event storming method, aggregates help to find those subdomains of responsibility. (Source Chris Richardson - Microservices Patterns)\n* [Database per service](https://microservices.io/patterns/data/database-per-service.html): Each service persists data privately and is accessible only via its API.\nServices are loosely coupled limiting impact to other services when schema changes occur in the database. The chosen database technology is driven by business requirements. (Source Chris Richardson - Microservices Patterns)\nThe implementation of transactions that span multiple services is complex and enforces using the Saga pattern. Queries that span multiple entities are a challenge and CQRS represents an interesting solution.\n* [Strangler pattern](#strangler-pattern): Used to incrementally migrate an existing, monolithic, application by replacing a set of features to a microservice but keep both running in parallel.\nApplying a domain driven design approach, you may strangle the application using bounded context. But then as soon as this pattern is applied, you need to assess the co-existence between\nexisting bounded contexts and the new microservices. One of the challenges will be to define where the write and read operations occurs, and how data should be replicated between the contexts.\nThis is where event driven architecture helps.\n* [Event sourcing](/patterns/event-sourcing/): persists, to an append log, the states of a business entity, such as an Order, as a sequence of immutable state-changing events.\n* [Command Query Responsibility Segregation](/patterns/cqrs/): helps to separate queries from commands and help to address queries with cross-microservice boundary.\n* [Saga pattern:](/patterns/saga/) Microservices publish events when something happens in the scope of their control like an update in the business entities they are responsible for. A microservice, interested in other business entities, subscribes to those events and it can update its own state and business entities on receipt of these events. Business entity keys need to be unique and immutable.\n* [Event reprocessing with dead letter](/patterns/dlq/): event driven microservices may have to call external services via a synchronous call. We need to process failure in order to get response from those services using event backbone.\n* [Transactional outbox](#transactional-outbox): A service command typically needs to update the database and send messages/events.\nThe approach is to use an outbox table to keep the message to sent and a message relay process to publish events inserted into database to the event backbone. (Source Chris Richardson - Microservices Patterns)\n\n\n## Strangler pattern\n\n### Problem\n\nHow to migrate a monolithic application to a microservice based architecture without doing the huge effort of redeveloping the application from a blank slate. Replacing and rewriting an existing application can be a huge investment. Rewriting a subset of business functions while running current application in parallel may be relevant and reduce risk and velocity of changes.\n\nThe figure below illustrates a typical mainframe application, with external Java based user interface connected to the mainframe via iop/corba and with three different applications to manage product, order and customer.\n\n![1](./images/strangler.png)\n\n### Solution\n\nThe approach is to use a \"strangler\" interface to dispatch a request to new or old features. Existing features to migrate are selected by trying to isolate sub components.\n\nOne of main challenges is to isolate the data store and disover how the new microservices and the legacy application are accessing the shared data. Continuous data replication can be a solution to propagate write model to read model. Write model will most likely stays on the monolitic application, change data capture can be used, with event backbone to propagate change to read model.\n\nThe facade needs to be scalable and not a single point of failure. It needs to support new APIs (RESTful) and old API (most likely SOAP).\n\nThe following figure illustrates an implementation using an event driven solution with data replication to synchronize the write model to the read model on the mainframe.\n\n![2](./images/strangler-2.png)\n\n## Transactional outbox\n\nWhen distributed transaction is not supported by the messaging middleware (like current Kafka version), it is important to ensure consistency between the records in the database and the events published. In the reference implementation we used the approach to publish to the topic as soon as an order is received via the API and then the same code, is consuming this events to persist to the database. With this approach if write to the topic operation fails, the application can return an error to the user, if the write operation to the database fails, the code can reload from the non-committed record. \n\nBut there is another solution presented by the transactional outbox. For detailed information about this pattern see the documentation of the pattern in Chris Richardson's site: [Transactional outbox](https://microservices.io/patterns/data/transactional-outbox.html).\n\nTo summarize this pattern, the approach is to use an `outbox` table to keep the messages to sent and a message relay process to publish events inserted into database to the event backbone. In modern solution this relay is a change data capture agent. The following schema illustrates the approach:\n\n![3](./images/outbox.png)\n\nTo get a concrete example of this pattern we have developed a [deep dive lab](/use-cases/db2-debezium/) using Quarkus Debezium outbox pattern and a DB2 database.","fileAbsolutePath":"/home/runner/work/refarch-eda/refarch-eda/docs/src/pages/patterns/intro/index.mdx"}}},"staticQueryHashes":["1054721580","1054721580","1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","768070550"]}