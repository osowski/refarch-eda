{"componentChunkName":"component---src-pages-use-cases-connect-s-3-index-mdx","path":"/use-cases/connect-s3/","result":{"pageContext":{"frontmatter":{"title":"Kafka Connect to S3 Source & Sink","description":"Apache Kafka to AWS S3 object storage Source & Sink Connector usecase"},"relativePagePath":"/use-cases/connect-s3/index.mdx","titleType":"append","MdxNode":{"id":"33cc5103-e359-5799-8a42-c550dec29b3e","children":[],"parent":"419901cf-a441-516b-a441-64312aa12259","internal":{"content":"---\ntitle: Kafka Connect to S3 Source & Sink\ndescription: Apache Kafka to AWS S3 object storage Source & Sink Connector usecase\n---\n\n<AnchorLinks>\n  <AnchorLink>Overview</AnchorLink>\n  <AnchorLink>Scenario prereqs</AnchorLink>\n  <AnchorLink>Kafka Connect Cluster</AnchorLink>\n  <AnchorLink>Kafka to S3 Sink Connector</AnchorLink>\n  <AnchorLink>S3 to Kafka Source Connector</AnchorLink>\n  <AnchorLink>Event Streams v10 Addendum</AnchorLink>\n  <AnchorLink>Troubleshooting</AnchorLink>\n  <AnchorLink>Next steps</AnchorLink>\n  <AnchorLink>References</AnchorLink>\n</AnchorLinks>\n\n## Overview\n\nThis scenario walkthrough will cover the usage of [IBM Event Streams](https://ibm.github.io/event-streams/about/overview/) as a Kafka provider and [Amazon S3](https://aws.amazon.com/s3/) as an object storage service as systems to integrate with the [Kafka Connect framework](https://ibm-cloud-architecture.github.io/refarch-eda/kafka/connect/). Through the use of the [Apache Camel opensource project](https://camel.apache.org/), we are able to use the [Apache Camel Kafka Connector](https://camel.apache.org/camel-kafka-connector/latest/index.html) in both a source and a sink capacity to provide bidirectional communication between [IBM Event Streams](https://ibm.github.io/event-streams/about/overview/) and [AWS S3](https://aws.amazon.com/s3/).\n\n![IBM Event Streams to S3 integration via Kafka Connect](https://github.com/ibm-cloud-architecture/refarch-eda/raw/master/docs-archive/kafka/images/eventstreams-to-s3-connector-flow.png)\n\nAs different use cases will require different configuration details to accommodate different situational requirements, the Kafka to S3 Source and Sink capabilities described here can be used to move data between S3 buckets with a Kafka topic being the middle-man or move data between Kafka topics with an S3 Bucket being the middle-man. However, take care to ensure that you do not create an infinite processing loop by writing to the same Kafka topics and the same S3 buckets with both a Source and Sink connector deployed at the same time.\n\n## Scenario prereqs\n\n**OpenShift Container Platform**\n\n- This deployment scenario was developed for use on the OpenShift Container Platform, with a minimum version of `4.2`.\n\n**Strimzi**\n- This deployment scenario will make use of the [Strimzi Operator](https://strimzi.io/docs/0.17.0/) for Kafka deployments and the custom resources it manages.\n- A minimum version of `0.17.0` is required for this scenario. This scenario has been explicitly validated with version `0.17.0`.\n- The simplest scenario is to deploy the Strimzi Operator to [watch all namespaces](https://strimzi.io/docs/0.17.0/#deploying-cluster-operator-to-watch-whole-cluster-deploying-co) for relevant custom resource creation and management.\n- This can be done in the OpenShift console via the **Operators > Operator Hub** page.\n\n**Amazon Web Services account**\n- As this scenario will make use of [AWS S3](https://aws.amazon.com/s3/), an active Amazon Web Services account is required.\n- Using the configuration described in this walkthrough, an additional IAM user can be created for further separation of permission, roles, and responsibilities.\n- This new IAM user should contain:\n  -  The [`AmazonS3FullAccess` policy](https://console.aws.amazon.com/iam/home?region=us-east-1#/policies/arn:aws:iam::aws:policy/AmazonS3FullAccess$serviceLevelSummary) attached to it _(as it will need both read and write access to S3)_,\n  -  An [S3 Bucket Policy](https://docs.aws.amazon.com/AmazonS3/latest/dev/walkthrough1.html) set on the Bucket to allow the IAM user to perform CRUD actions on the bucket and its objects.\n- Create a file named `aws-credentials.properties` with the following format:\n\n   ```\n   aws_access_key_id=AKIA123456EXAMPLE\n   aws_secret_access_key=strWrz/bb8%c3po/r2d2EXAMPLEKEY\n   ```\n\n- Create a Kubernetes Secret from this file to inject into the Kafka Connect cluster at runtime:\n\n   ```shell\n   kubectl create secret generic aws-credentials --from-file=aws-credentials.properties\n   ```\n- _Additional work is underway to enable configuration of the components to make use of IAM Roles instead._\n\n\n**IBM Event Streams API Key**\n- This scenario is written with [IBM Event Streams](https://ibm.github.io/event-streams/about/overview/) as the provider of the Kafka endpoints.\n- API Keys are required for connectivity to the Kafka brokers and interaction with Kafka topics.\n- An API key should be created with (at minimum) read and write access to the source and target Kafka topics the connectors will interact with.\n- A Kubernetes Secret must be created with the Event Streams API to inject into the Kafka Connect cluster at runtime:\n\n   ```shell\n   kubectl create secret generic eventstreams-apikey --from-literal=password=<eventstreams_api_key>\n   ```\n\n**IBM Event Streams Certificates on IBM Cloud Pak for Integration**\n- If you are using an IBM Event Streams instance deployed via the IBM Cloud Pak for Integration, you must also download the generated truststore file to provide TLS communication between the connectors and the Kafka brokers.\n- This file, along with its password, can be found on the **Connect to this cluster** dialog in the Event Streams UI.\n- Once downloaded, it must be configured to work with the Kafka Connect certificate deployment pattern:\n\n   ```shell\n   keytool -importkeystore -srckeystore es-cert.jks -destkeystore es-cert.p12 -deststoretype PKCS12\n   openssl pkcs12 -in es-cert.p12 -nokeys -out es-cert.crt\n   kubectl create secret generic eventstreams-truststore-cert --from-file=es-cert.crt\n   ```\n\n**IBM Event Streams Certificates on IBM Cloud**\n- If you are using an IBM Event Streams instance deployed on IBM Cloud, you need to provide the root CA certificate to connect correctly from the Kafka Connect instance.\n- This file can be downloaded as `eventstreams.cloud.ibm.com.cer` from the endpoint defined in your service credentials via the `kafka_http_url` property.\n- Once downloaded, it must be configured to work with the Kafka Connect certificate deployment pattern:\n\n   ```shell\n   openssl x509 -inform DER -in eventstreams.cloud.ibm.com.cer -out es-cert.crt\n   kubectl create secret generic eventstreams-truststore-cert --from-file=es-cert.crt\n   ```\n\n## Kafka Connect Cluster\n\nWe will take advantage of some of the developer experience improvements that OpenShift and the Strimi Operator brings to the Kafka Connect framework. The Strimzi Operator provides a `KafkaConnect` custom resource which will manage a Kafka Connect cluster for us with minimal system interaction. The only work we need to do is to update the container image that the Kafka Connect deployment will use with the necessary Camel Kafka Connector binaries, which OpenShift can help us with through the use of its Build capabilities.\n\n#### (Optional) Create ConfigMap for log4j configuration\n\nDue to the robust nature of Apache Camel, the default logging settings for the Apache Kafka Connect classes will send potentially sensitive information to the logs during Apache Camel context configuration. To avoid this, we can provide an updated logging configuration to the `log4j` configuration that is used by our deployments.\n\nSave the properties file below and name it `log4j.properties`. Then create a ConfigMap via `kubectl create configmap custom-connect-log4j --from-file=log4j.properties`. This ConfigMap will then be used in our KafkaConnect cluster creation to filter out any logging output containing `accesskey` or `secretkey` permutations.\n\n```properties\n# Do not change this generated file. Logging can be configured in the corresponding kubernetes/openshift resource.\nlog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\nlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\nlog4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %p %m (%c) [%t]%n\nconnect.root.logger.level=INFO\nlog4j.rootLogger=${connect.root.logger.level}, CONSOLE\nlog4j.logger.org.apache.zookeeper=ERROR\nlog4j.logger.org.I0Itec.zkclient=ERROR\nlog4j.logger.org.reflections=ERROR\n\n# Due to back-leveled version of log4j that is included in Kafka Connect,\n# we can use multiple StringMatchFilters to remove all the permutations\n# of the AWS accessKey and secretKey values that may get dumped to stdout\n# and thus into any connected logging system.\nlog4j.appender.CONSOLE.filter.a=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.a.StringToMatch=accesskey\nlog4j.appender.CONSOLE.filter.a.AcceptOnMatch=false\nlog4j.appender.CONSOLE.filter.b=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.b.StringToMatch=accessKey\nlog4j.appender.CONSOLE.filter.b.AcceptOnMatch=false\nlog4j.appender.CONSOLE.filter.c=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.c.StringToMatch=AccessKey\nlog4j.appender.CONSOLE.filter.c.AcceptOnMatch=false\nlog4j.appender.CONSOLE.filter.d=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.d.StringToMatch=ACCESSKEY\nlog4j.appender.CONSOLE.filter.d.AcceptOnMatch=false\n\nlog4j.appender.CONSOLE.filter.e=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.e.StringToMatch=secretkey\nlog4j.appender.CONSOLE.filter.e.AcceptOnMatch=false\nlog4j.appender.CONSOLE.filter.f=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.f.StringToMatch=secretKey\nlog4j.appender.CONSOLE.filter.f.AcceptOnMatch=false\nlog4j.appender.CONSOLE.filter.g=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.g.StringToMatch=SecretKey\nlog4j.appender.CONSOLE.filter.g.AcceptOnMatch=false\nlog4j.appender.CONSOLE.filter.h=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.h.StringToMatch=SECRETKEY\nlog4j.appender.CONSOLE.filter.h.AcceptOnMatch=false\n```\n\n#### Deploy the baseline Kafka Connect Cluster\n\nReview the YAML description for our `KafkaConnectS2I` custom resource below, named `connect-cluster-101`. Pay close attention to _(using YAML notation)_:\n- `spec.logging.name` should point to the name of the ConfigMap created in the previous step to configure custom `log4j` logging filters _(optional)_\n- `spec.bootstrapServers` should be updated with your local Event Streams endpoints\n- `spec.tls.trustedCertificates[0].secretName` should match the Kubernetes Secret containing the IBM Event Streams certificate\n- `spec.authentication.passwordSecret.secretName` should match the Kubernetes Secret containing the IBM Event Streams API key\n- `spec.externalConfiguration.volumes[0].secret.secretName` should match the Kubernetes Secret containing your AWS credentials\n- `spec.config['group.id']` should be a unique name for this Kafka Connect cluster across all Kafka Connect instances that will be communicating with the same set of Kafka brokers.\n- `spec.config['*.storage.topic']` should be updated to provide unique topics for this Kafka Connect cluster inside your Kafka deployment. Distinct Kafka Connect clusters should not share metadata topics.\n\n```yaml\napiVersion: kafka.strimzi.io/v1alpha1\nkind: KafkaConnectS2I\nmetadata:\n  name: connect-cluster-101\n  annotations:\n    strimzi.io/use-connector-resources: \"true\"\nspec:\n  #logging:\n  #  type: external\n  #  name: custom-connect-log4j\n  replicas: 1\n  bootstrapServers: es-1-ibm-es-proxy-route-bootstrap-eventstreams.apps.cluster.local:443\n  tls:\n    trustedCertificates:\n      - certificate: es-cert.crt\n        secretName: eventstreams-truststore-cert\n  authentication:\n    passwordSecret:\n      secretName: eventstreams-apikey\n      password: password\n    username: token\n    type: plain\n  externalConfiguration:\n    volumes:\n      - name: aws-credentials\n        secret:\n          secretName: aws-credentials\n  config:\n    group.id: connect-cluster-101\n    config.providers: file\n    config.providers.file.class: org.apache.kafka.common.config.provider.FileConfigProvider\n    key.converter: org.apache.kafka.connect.json.JsonConverter\n    value.converter: org.apache.kafka.connect.json.JsonConverter\n    key.converter.schemas.enable: false\n    value.converter.schemas.enable: false\n    offset.storage.topic: connect-cluster-101-offsets\n    config.storage.topic: connect-cluster-101-configs\n    status.storage.topic: connect-cluster-101-status\n```\n\nSave the YAML above into a file named `kafka-connect.yaml`. If you created the ConfigMap in the previous step to filter out `accesskey` and `secretkey` values from the logs, uncomment the `spec.logging` lines to allow for the custom logging filters to be enabled during Kafka Connect cluster creation. Then this resource can be created via `kubectl apply -f kafka-connect.yaml`. You can then tail the output of the `connect-cluster-101` pods for updates on the connector status.\n\n#### Build the Camel Kafka Connector\n\nThe next step is to build the Camel Kafka Connector binaries so that they can be loaded into the just-deployed Kafka Connect cluster's container images.\n\n1. Clone the repository https://github.com/osowski/camel-kafka-connector to your local machine:\n   - `git clone https://github.com/osowski/camel-kafka-connector.git`\n2. Check out the `camel-kafka-connector-0.1.0-branch`:\n   - `git checkout camel-kafka-connector-0.1.0-branch`\n3. From the root directory of the repository, build the project components:\n   - `mvn clean package`\n4. Go get a coffee and take a walk... as this build will take around 30 minutes on a normal developer workstation.\n   - To reduce the overall build scope of the project, you can comment out the undesired modules from the `<modules>` element of the `connectors/pom.xml` using `<!-- -->` notation.\n5. Copy the generated S3 artifacts to the core package build artifacts:\n   - `cp connectors/camel-aws-s3-kafka-connector/target/camel-aws-s3-kafka-connector-0.1.0.jar core/target/camel-kafka-connector-0.1.0-package/share/java/camel-kafka-connector/`\n\nSome items to note:\n- The repository used here (https://github.com/osowski/camel-kafka-connector) is a fork of the official repository (https://github.com/apache/camel-kafka-connector) with a minor update applied to allow for dynamic endpoints to be specified via configuration, which is critical for our [Kafka to S3 Sink Connector](#kafka-to-s3-sink-connector) scenario.\n- This step (and the next step) will eventually be eliminated by providing an existing container image with the necessary Camel Kafka Connector binaries as part of a build system.\n\n#### Deploy the Camel Kafka Connector binaries\n\nNow that the Camel Kafka Connector binaries have been built, we need to include them on the classpath inside of the container image which our Kafka Connect clusters are using.\n\n1. From the root directory of the repository, start a new OpenShift Build, using the generated build artifacts:\n   ```shell\n   oc start-build connect-cluster-101-connect --from-dir=./core/target/camel-kafka-connector-0.1.0-package/share/java --follow\n   ```\n2. Watch the Kubernetes pods as they are updated with the new build and rollout of the Kafka Connect Cluster using the updated container image _(which now includes the Camel Kafka Connector binaries)_:\n   ```shell\n   kubectl get pods -w\n   ```\n3. Once the `connect-cluster-101-connect-2-[random-suffix]` pod is in a `Running` state, you can proceed.\n\n## Kafka to S3 Sink Connector\n\nNow that you have a Kafka Connect cluster up and running, you will need to configure a connector to actually begin the transmission of data from one system to the other. This will be done by taking advantage of Strimzi and using the [`KafkaConnector` custom resource](https://strimzi.io/docs/0.17.0/#kafkaconnector_resources) the Strimzi Operator manages for us.\n\nReview the YAML description for our `KafkaConnector` custom resource below, named `s3-sink-connector`. Pay close attention to:\n- The `strimzi.io/cluster` label must match the deployed Kafka Connect cluster you previously deployed _(or else Strimzi will not connect the `KafkaConnector` to your `KafkaConnect` cluster)_\n- The `topics` parameter _(named `my-source-topic` here)_\n- The S3 Bucket parameter of the `camel.sink.url` configuration option _(named `my-s3-bucket` here)_\n\n```yaml\napiVersion: kafka.strimzi.io/v1alpha1\nkind: KafkaConnector\nmetadata:\n  name: s3-sink-connector\n  labels:\n    strimzi.io/cluster: connect-cluster-101\nspec:\n  class: org.apache.camel.kafkaconnector.CamelSinkConnector\n  tasksMax: 1\n  config:\n    key.converter: org.apache.kafka.connect.storage.StringConverter\n    value.converter: org.apache.kafka.connect.storage.StringConverter\n    topics: my-source-topic\n    camel.sink.url: aws-s3://my-s3-bucket?keyName=${date:now:yyyyMMdd-HHmmssSSS}-${exchangeId}\n    camel.sink.maxPollDuration: 10000\n    camel.component.aws-s3.configuration.autocloseBody: false\n    camel.component.aws-s3.accessKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_access_key_id}\n    camel.component.aws-s3.secretKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_secret_access_key}\n    camel.component.aws-s3.region: US_EAST_1\n```\n\nOnce you have updated the YAML and saved it in a file named `kafka-sink-connector.yaml`, this resource can be created via `kubectl apply -f kafka-sink-connector.yaml`. You can then tail the output of the `connect-cluster-101` pods for updates on the connector status.\n\n**NOTE:** If you require objects in S3 to reside in a sub-folder of the bucket root, you can place a folder name prefix in the `keyName` query parameter of the `camel.sink.url` configuration option above. For example, `camel.sink.url: aws-s3://my-s3-bucket?keyName=myfoldername/${date:now:yyyyMMdd-HHmmssSSS}-${exchangeId}`.\n\n## S3 to Kafka Source Connector\n\nSimilar to the [Kafka to S3 Sink Connector](#kafka-to-s3-sink-connector) scenario, this scenario will make use of the Strimzi [`KafkaConnector` custom resource](https://strimzi.io/docs/0.17.0/#kafkaconnector_resources) to configure the specific connector instance.\n\nReview the YAML description for our `KafkaConnector` custom resource below, named `s3-source-connector`. Pay close attention to:\n- The `strimzi.io/cluster` label must match the deployed Kafka Connect cluster you previously deployed _(or else Strimzi will not connect the `KafkaConnector` to your `KafkaConnect` cluster)_\n- The `topics` and `camel.source.kafka.topic` parameters _(named `my-target-topic` here)_\n- The S3 Bucket parameter of the `camel.sink.url` configuration option _(named `my-s3-bucket` here)_\n\n**Please note** that it is an explicit intention that the topics used in the [Kafka to S3 Sink Connector](#kafka-to-s3-sink-connector) configuration and the [S3 to Kafka Source Connector](#s3-to-kafka-source-connector) configuration are different. If these configurations were to use the **same Kafka topic** and the **same S3 Bucket**, we would create an infinite processing loop of the same information being endlessly recycled through the system. In our example deployments here, we are deploying to different topics but the same S3 Bucket.\n\n```yaml\napiVersion: kafka.strimzi.io/v1alpha1\nkind: KafkaConnector\nmetadata:\n  name: s3-source-connector\n  labels:\n    strimzi.io/cluster: connect-cluster-101\nspec:\n  class: org.apache.camel.kafkaconnector.CamelSourceConnector\n  tasksMax: 1\n  config:\n    key.converter: org.apache.kafka.connect.storage.StringConverter\n    value.converter: org.apache.camel.kafkaconnector.awss3.converters.S3ObjectConverter\n    topics: my-target-topic\n    camel.source.kafka.topic: my-target-topic\n    camel.source.url: aws-s3://my-s3-bucket?autocloseBody=false\n    camel.source.maxPollDuration: 10000\n    camel.component.aws-s3.accessKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_access_key_id}\n    camel.component.aws-s3.secretKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_secret_access_key}\n    camel.component.aws-s3.region: US_EAST_1\n```\n\nOnce you have updated the YAML and saved it in a file named `kafka-source-connector.yaml`, this resource can be created via `kubectl apply -f kafka-source-connector.yaml`. You can then tail the output of the `connect-cluster-101` pods for updates on the connector status.\n\n**NOTE:** If you require the connector to only read objects from a subdirecotry of the S3 bucket root, you can set the `camel.component.aws-s3.configuration.prefix` configuration option with the value of the subdirectory name. For example, `camel.component.aws-s3.configuration.prefix: myfoldername` .\n\n\n## Event Streams v10 Addendum\n\n- The steps up to now assumed usage of an OpenShift Container Platform v4.3.x cluster, IBM Cloud Pak for Integration v2020.1.1 and IBM Event Streams v2019.4.2\n- With the release of Event Streams v10 (which is built on top of the Strimzi Kafka Operator) and the new CP4I there are some things need that need to be adjusted in the yamls to reflect that.\n\n- You can edit the previous `kafka-connect.yaml` or create a new file.\n**kafka-connect-esv10.yaml**\n```yaml\napiVersion: eventstreams.ibm.com/v1beta1\nkind: KafkaConnectS2I\nmetadata:\n  name: connect-cluster-101\n  annotations:\n    eventstreams.ibm.com/use-connector-resources: \"true\"\nspec:\n  #logging:\n  #  type: external\n  #  name: custom-connect-log4j\n  version: 2.5.0\n  replicas: 1\n  bootstrapServers: {internal-bootstrap-server-address}\n  template:\n    pod:\n      imagePullSecrets: []\n      metadata:\n        annotations:\n          eventstreams.production.type: CloudPakForIntegrationNonProduction\n          productID: {product-id}\n          productName: IBM Event Streams for Non Production\n          productVersion: 10.0.0\n          productMetric: VIRTUAL_PROCESSOR_CORE\n          productChargedContainers: {connect-cluster-101}-connect\n          cloudpakId: {cloudpak-id}\n          cloudpakName: IBM Cloud Pak for Integration\n          cloudpakVersion: 2020.2.1\n          productCloudpakRatio: \"2:1\"\n  tls:\n      trustedCertificates:\n        - secretName: {your-es-instance-name}-cluster-ca-cert\n          certificate: ca.crt\n  authentication:\n    type: tls\n    certificateAndKey:\n      certificate: user.crt\n      key: user.key\n      secretName: {generated-secret-from-ui}\n  externalConfiguration:\n    volumes:\n      - name: aws-credentials\n        secret:\n          secretName: aws-credentials\n  config:\n    group.id: connect-cluster-101\n    config.providers: file\n    config.providers.file.class: org.apache.kafka.common.config.provider.FileConfigProvider\n    key.converter: org.apache.kafka.connect.json.JsonConverter\n    value.converter: org.apache.kafka.connect.json.JsonConverter\n    key.converter.schemas.enable: false\n    value.converter.schemas.enable: false\n    offset.storage.topic: connect-cluster-101-offsets\n    config.storage.topic: connect-cluster-101-configs\n    status.storage.topic: connect-cluster-101-status\n```\n\n- There are a couple changes of note here.\n  - `apiVersion: eventstreams.ibm.com/v1beta1` instead of the previous Strimzi one.\n  - `metadata.annotations.eventstreams.ibm.com/use-connector-resources: \"true\"` instead of the previous Strimzi one as well.\n  - `spec.bootstrapservers:` Previously in Event Streams v2019.4.2 and prior there was only a single external facing route for this bootstrap server address. In Event Streams v10 there is an `External` and `Internal` one now. Replace `{internal-bootstrap-server-address}` with the `Internal` bootstrap server address from the Event Streams v10 UI.\n  - `spec.template.pod.metadata.annotations.*` This entire section is new and represents new metadata that the Event Streams instance needs.\n  - `spec.template.pod.metadata.annotations.productID` You can find this value when trying to deploy an Event Streams Custom Resource from the Installed Event Streams Operator YAML deployment or when applying this YAML through the command-line, OCP will provide you the proper values if they're wrong.\n  - `spec.template.pod.metadata.annotations.cloudpakId` Same as productID.\n  - `spec.tls.trustedCertificates` This is different from the previous one in that this certificate was automatically generated on creation of your Event Streams Kafka Cluster. If your Event Streams instance is named `eventstreams-dev` then this value should be `eventstreams-dev-cluster-ca-cert`.\n  - `spec.authentication.*` This section is mostly different from the previous section. Prior we used a generated API Key, but on Event Streams v10 we will need to generate TLS credentials. In the `Internal` connection details there will be a `Generate TLS Credentials` button. Here you can name your secret and provide the proper access to it. **Note 1** - This is automatically created by the Event Streams Operator into the same namespace as both a `KafkaUser` Custom Resource as well as a secret. If your secret is named `internal-secret` then there will be an automatically generated Kubernetes/OpenShift secret named that as well as a `KafkaUser`. `user.crt` and `user.key` are certificates automatically generated within said secret. **Note 2** - Deletion of that secret will replicate itself. You will need to delete the associated and created `KafkaUser`.\n\n**kafka-sink-connector.yaml-esv10.yaml**\n```yaml\napiVersion: eventstreams.ibm.com/v1alpha1\nkind: KafkaConnector\nmetadata:\n  name: s3-sink-connector\n  labels:\n    eventstreams.ibm.com/cluster: connect-cluster-101\nspec:\n  class: org.apache.camel.kafkaconnector.CamelSinkConnector\n  tasksMax: 1\n  config:\n    key.converter: org.apache.kafka.connect.storage.StringConverter\n    value.converter: org.apache.kafka.connect.storage.StringConverter\n    topics: my-topic\n    camel.sink.url: aws-s3://my-s3-bucket?keyName=${date:now:yyyyMMdd-HHmmssSSS}-${exchangeId}\n    camel.sink.maxPollDuration: 10000\n    camel.component.aws-s3.configuration.autocloseBody: false\n    camel.component.aws-s3.accessKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_access_key_id}\n    camel.component.aws-s3.secretKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_secret_access_key}\n    camel.component.aws-s3.region: my-s3-bucket-region\n```\n- For the most part identical besides two minor changes.\n  - `apiVersion: eventstreams.ibm.com/v1alpha1` instead of Strimzi.\n  - `metadata.labels.eventstreams.ibm.com/cluster: connect-cluster-101` again instead of Strimzi.\n\n**kafka-source-connector.yaml-esv10.yaml**\n```yaml\napiVersion: eventstreams.ibm.com/v1alpha1\nkind: KafkaConnector\nmetadata:\n  name: s3-source-connector\n  labels:\n    eventstreams.ibm.com/cluster: connect-cluster-101\nspec:\n  class: org.apache.camel.kafkaconnector.CamelSourceConnector\n  tasksMax: 1\n  config:\n    key.converter: org.apache.kafka.connect.storage.StringConverter\n    value.converter: org.apache.camel.kafkaconnector.awss3.converters.S3ObjectConverter\n    topics: my-topic\n    camel.source.kafka.topic: my-topic\n    camel.source.url: aws-s3://my-s3-bucket?autocloseBody=false\n    camel.source.maxPollDuration: 10000\n    camel.component.aws-s3.accessKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_access_key_id}\n    camel.component.aws-s3.secretKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_secret_access_key}\n    camel.component.aws-s3.region: my-s3-bucket-region\n```\n- Similar to the S3 sink connector yaml.\n  - `apiVersion: eventstreams.ibm.com/v1alpha1` instead of Strimzi.\n  - `metadata.labels.eventstreams.ibm.com/cluster: connect-cluster-101` again instead of Strimzi.\n\n\n\n## Troubleshooting\n\n* The log output from the Kafka Connector instances will be available in the KafkaConnectS2I pods, named in the pattern of `{connect-cluster-name}-connect-{latest-build-id}-{random-suffix}`. This pattern will be referred to as `{connect-pod}` throughout the rest of the **Troubleshooting** section.\n\n\n* To increase the logging output of the deployed connector instances:\n  - Follow the steps for **\"Create ConfigMap for log4j configuration\"** in [Kafka Connect Cluster](#kafka-connect-cluster) above\n  - Update the `log4j.properties` ConfigMap to include the line `log4j.logger.org.apache.camel.kafkaconnector=DEBUG`\n  - Reapply the YAML configuration of the KafkaConnectS2I cluster\n\n\n* To check the deployment status of applied Kafka Connect configuration via Kafka Connect's REST API, run the following commands:\n  - `oc exec {connect-pod} bash -- -c \"curl --silent http://localhost:8083/connectors/\"`\n  - `oc exec {connect-pod} bash -- -c \"curl --silent http://localhost:8083/connectors/{deployed-connector-name}/status\"`\n\n## Next steps\n\n- Enable use  of IAM Credentials in the Connector configuration _(as the default Java code currently outputs `aws_access_key_id` and `aws_secret_access_key` to container runtime logs due to their existence as configuration properties)_\n- Optionally configure individual connector instances to startup with offset value of -1 _(to enable to run from beginning of available messages)_\n- Implement a build system to produce container images with the Camel Kafka Connector binaries already present\n\n## References\n- [Apache Camel Kafka Connector - Try it out on OpenShift with Strimzi](https://camel.apache.org/camel-kafka-connector/latest/try-it-out-on-openshift-with-strimzi.html)\n- [Apache Camel - Available pattern elements](https://camel.apache.org/components/latest/languages/simple-language.html) for use in the `keyName` parameter of the `camel.sink.url` property.\n- [Apache Camel - Dynamic Endpoint reference](https://camel.apache.org/components/latest/eips/toD-eip.html)\n- [Red Hat Developer Blog - Using secrets in Kafka Connect configuration](https://developers.redhat.com/blog/2020/02/14/using-secrets-in-apache-kafka-connect-configuration/)\n- [Apache Kafka - Connect Overview](http://kafka.apache.org/documentation/#connect)\n","type":"Mdx","contentDigest":"bf28f9b5003c331e476ff5088e1eb3bc","owner":"gatsby-plugin-mdx","counter":620},"frontmatter":{"title":"Kafka Connect to S3 Source & Sink","description":"Apache Kafka to AWS S3 object storage Source & Sink Connector usecase"},"exports":{},"rawBody":"---\ntitle: Kafka Connect to S3 Source & Sink\ndescription: Apache Kafka to AWS S3 object storage Source & Sink Connector usecase\n---\n\n<AnchorLinks>\n  <AnchorLink>Overview</AnchorLink>\n  <AnchorLink>Scenario prereqs</AnchorLink>\n  <AnchorLink>Kafka Connect Cluster</AnchorLink>\n  <AnchorLink>Kafka to S3 Sink Connector</AnchorLink>\n  <AnchorLink>S3 to Kafka Source Connector</AnchorLink>\n  <AnchorLink>Event Streams v10 Addendum</AnchorLink>\n  <AnchorLink>Troubleshooting</AnchorLink>\n  <AnchorLink>Next steps</AnchorLink>\n  <AnchorLink>References</AnchorLink>\n</AnchorLinks>\n\n## Overview\n\nThis scenario walkthrough will cover the usage of [IBM Event Streams](https://ibm.github.io/event-streams/about/overview/) as a Kafka provider and [Amazon S3](https://aws.amazon.com/s3/) as an object storage service as systems to integrate with the [Kafka Connect framework](https://ibm-cloud-architecture.github.io/refarch-eda/kafka/connect/). Through the use of the [Apache Camel opensource project](https://camel.apache.org/), we are able to use the [Apache Camel Kafka Connector](https://camel.apache.org/camel-kafka-connector/latest/index.html) in both a source and a sink capacity to provide bidirectional communication between [IBM Event Streams](https://ibm.github.io/event-streams/about/overview/) and [AWS S3](https://aws.amazon.com/s3/).\n\n![IBM Event Streams to S3 integration via Kafka Connect](https://github.com/ibm-cloud-architecture/refarch-eda/raw/master/docs-archive/kafka/images/eventstreams-to-s3-connector-flow.png)\n\nAs different use cases will require different configuration details to accommodate different situational requirements, the Kafka to S3 Source and Sink capabilities described here can be used to move data between S3 buckets with a Kafka topic being the middle-man or move data between Kafka topics with an S3 Bucket being the middle-man. However, take care to ensure that you do not create an infinite processing loop by writing to the same Kafka topics and the same S3 buckets with both a Source and Sink connector deployed at the same time.\n\n## Scenario prereqs\n\n**OpenShift Container Platform**\n\n- This deployment scenario was developed for use on the OpenShift Container Platform, with a minimum version of `4.2`.\n\n**Strimzi**\n- This deployment scenario will make use of the [Strimzi Operator](https://strimzi.io/docs/0.17.0/) for Kafka deployments and the custom resources it manages.\n- A minimum version of `0.17.0` is required for this scenario. This scenario has been explicitly validated with version `0.17.0`.\n- The simplest scenario is to deploy the Strimzi Operator to [watch all namespaces](https://strimzi.io/docs/0.17.0/#deploying-cluster-operator-to-watch-whole-cluster-deploying-co) for relevant custom resource creation and management.\n- This can be done in the OpenShift console via the **Operators > Operator Hub** page.\n\n**Amazon Web Services account**\n- As this scenario will make use of [AWS S3](https://aws.amazon.com/s3/), an active Amazon Web Services account is required.\n- Using the configuration described in this walkthrough, an additional IAM user can be created for further separation of permission, roles, and responsibilities.\n- This new IAM user should contain:\n  -  The [`AmazonS3FullAccess` policy](https://console.aws.amazon.com/iam/home?region=us-east-1#/policies/arn:aws:iam::aws:policy/AmazonS3FullAccess$serviceLevelSummary) attached to it _(as it will need both read and write access to S3)_,\n  -  An [S3 Bucket Policy](https://docs.aws.amazon.com/AmazonS3/latest/dev/walkthrough1.html) set on the Bucket to allow the IAM user to perform CRUD actions on the bucket and its objects.\n- Create a file named `aws-credentials.properties` with the following format:\n\n   ```\n   aws_access_key_id=AKIA123456EXAMPLE\n   aws_secret_access_key=strWrz/bb8%c3po/r2d2EXAMPLEKEY\n   ```\n\n- Create a Kubernetes Secret from this file to inject into the Kafka Connect cluster at runtime:\n\n   ```shell\n   kubectl create secret generic aws-credentials --from-file=aws-credentials.properties\n   ```\n- _Additional work is underway to enable configuration of the components to make use of IAM Roles instead._\n\n\n**IBM Event Streams API Key**\n- This scenario is written with [IBM Event Streams](https://ibm.github.io/event-streams/about/overview/) as the provider of the Kafka endpoints.\n- API Keys are required for connectivity to the Kafka brokers and interaction with Kafka topics.\n- An API key should be created with (at minimum) read and write access to the source and target Kafka topics the connectors will interact with.\n- A Kubernetes Secret must be created with the Event Streams API to inject into the Kafka Connect cluster at runtime:\n\n   ```shell\n   kubectl create secret generic eventstreams-apikey --from-literal=password=<eventstreams_api_key>\n   ```\n\n**IBM Event Streams Certificates on IBM Cloud Pak for Integration**\n- If you are using an IBM Event Streams instance deployed via the IBM Cloud Pak for Integration, you must also download the generated truststore file to provide TLS communication between the connectors and the Kafka brokers.\n- This file, along with its password, can be found on the **Connect to this cluster** dialog in the Event Streams UI.\n- Once downloaded, it must be configured to work with the Kafka Connect certificate deployment pattern:\n\n   ```shell\n   keytool -importkeystore -srckeystore es-cert.jks -destkeystore es-cert.p12 -deststoretype PKCS12\n   openssl pkcs12 -in es-cert.p12 -nokeys -out es-cert.crt\n   kubectl create secret generic eventstreams-truststore-cert --from-file=es-cert.crt\n   ```\n\n**IBM Event Streams Certificates on IBM Cloud**\n- If you are using an IBM Event Streams instance deployed on IBM Cloud, you need to provide the root CA certificate to connect correctly from the Kafka Connect instance.\n- This file can be downloaded as `eventstreams.cloud.ibm.com.cer` from the endpoint defined in your service credentials via the `kafka_http_url` property.\n- Once downloaded, it must be configured to work with the Kafka Connect certificate deployment pattern:\n\n   ```shell\n   openssl x509 -inform DER -in eventstreams.cloud.ibm.com.cer -out es-cert.crt\n   kubectl create secret generic eventstreams-truststore-cert --from-file=es-cert.crt\n   ```\n\n## Kafka Connect Cluster\n\nWe will take advantage of some of the developer experience improvements that OpenShift and the Strimi Operator brings to the Kafka Connect framework. The Strimzi Operator provides a `KafkaConnect` custom resource which will manage a Kafka Connect cluster for us with minimal system interaction. The only work we need to do is to update the container image that the Kafka Connect deployment will use with the necessary Camel Kafka Connector binaries, which OpenShift can help us with through the use of its Build capabilities.\n\n#### (Optional) Create ConfigMap for log4j configuration\n\nDue to the robust nature of Apache Camel, the default logging settings for the Apache Kafka Connect classes will send potentially sensitive information to the logs during Apache Camel context configuration. To avoid this, we can provide an updated logging configuration to the `log4j` configuration that is used by our deployments.\n\nSave the properties file below and name it `log4j.properties`. Then create a ConfigMap via `kubectl create configmap custom-connect-log4j --from-file=log4j.properties`. This ConfigMap will then be used in our KafkaConnect cluster creation to filter out any logging output containing `accesskey` or `secretkey` permutations.\n\n```properties\n# Do not change this generated file. Logging can be configured in the corresponding kubernetes/openshift resource.\nlog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\nlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\nlog4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %p %m (%c) [%t]%n\nconnect.root.logger.level=INFO\nlog4j.rootLogger=${connect.root.logger.level}, CONSOLE\nlog4j.logger.org.apache.zookeeper=ERROR\nlog4j.logger.org.I0Itec.zkclient=ERROR\nlog4j.logger.org.reflections=ERROR\n\n# Due to back-leveled version of log4j that is included in Kafka Connect,\n# we can use multiple StringMatchFilters to remove all the permutations\n# of the AWS accessKey and secretKey values that may get dumped to stdout\n# and thus into any connected logging system.\nlog4j.appender.CONSOLE.filter.a=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.a.StringToMatch=accesskey\nlog4j.appender.CONSOLE.filter.a.AcceptOnMatch=false\nlog4j.appender.CONSOLE.filter.b=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.b.StringToMatch=accessKey\nlog4j.appender.CONSOLE.filter.b.AcceptOnMatch=false\nlog4j.appender.CONSOLE.filter.c=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.c.StringToMatch=AccessKey\nlog4j.appender.CONSOLE.filter.c.AcceptOnMatch=false\nlog4j.appender.CONSOLE.filter.d=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.d.StringToMatch=ACCESSKEY\nlog4j.appender.CONSOLE.filter.d.AcceptOnMatch=false\n\nlog4j.appender.CONSOLE.filter.e=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.e.StringToMatch=secretkey\nlog4j.appender.CONSOLE.filter.e.AcceptOnMatch=false\nlog4j.appender.CONSOLE.filter.f=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.f.StringToMatch=secretKey\nlog4j.appender.CONSOLE.filter.f.AcceptOnMatch=false\nlog4j.appender.CONSOLE.filter.g=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.g.StringToMatch=SecretKey\nlog4j.appender.CONSOLE.filter.g.AcceptOnMatch=false\nlog4j.appender.CONSOLE.filter.h=org.apache.log4j.varia.StringMatchFilter\nlog4j.appender.CONSOLE.filter.h.StringToMatch=SECRETKEY\nlog4j.appender.CONSOLE.filter.h.AcceptOnMatch=false\n```\n\n#### Deploy the baseline Kafka Connect Cluster\n\nReview the YAML description for our `KafkaConnectS2I` custom resource below, named `connect-cluster-101`. Pay close attention to _(using YAML notation)_:\n- `spec.logging.name` should point to the name of the ConfigMap created in the previous step to configure custom `log4j` logging filters _(optional)_\n- `spec.bootstrapServers` should be updated with your local Event Streams endpoints\n- `spec.tls.trustedCertificates[0].secretName` should match the Kubernetes Secret containing the IBM Event Streams certificate\n- `spec.authentication.passwordSecret.secretName` should match the Kubernetes Secret containing the IBM Event Streams API key\n- `spec.externalConfiguration.volumes[0].secret.secretName` should match the Kubernetes Secret containing your AWS credentials\n- `spec.config['group.id']` should be a unique name for this Kafka Connect cluster across all Kafka Connect instances that will be communicating with the same set of Kafka brokers.\n- `spec.config['*.storage.topic']` should be updated to provide unique topics for this Kafka Connect cluster inside your Kafka deployment. Distinct Kafka Connect clusters should not share metadata topics.\n\n```yaml\napiVersion: kafka.strimzi.io/v1alpha1\nkind: KafkaConnectS2I\nmetadata:\n  name: connect-cluster-101\n  annotations:\n    strimzi.io/use-connector-resources: \"true\"\nspec:\n  #logging:\n  #  type: external\n  #  name: custom-connect-log4j\n  replicas: 1\n  bootstrapServers: es-1-ibm-es-proxy-route-bootstrap-eventstreams.apps.cluster.local:443\n  tls:\n    trustedCertificates:\n      - certificate: es-cert.crt\n        secretName: eventstreams-truststore-cert\n  authentication:\n    passwordSecret:\n      secretName: eventstreams-apikey\n      password: password\n    username: token\n    type: plain\n  externalConfiguration:\n    volumes:\n      - name: aws-credentials\n        secret:\n          secretName: aws-credentials\n  config:\n    group.id: connect-cluster-101\n    config.providers: file\n    config.providers.file.class: org.apache.kafka.common.config.provider.FileConfigProvider\n    key.converter: org.apache.kafka.connect.json.JsonConverter\n    value.converter: org.apache.kafka.connect.json.JsonConverter\n    key.converter.schemas.enable: false\n    value.converter.schemas.enable: false\n    offset.storage.topic: connect-cluster-101-offsets\n    config.storage.topic: connect-cluster-101-configs\n    status.storage.topic: connect-cluster-101-status\n```\n\nSave the YAML above into a file named `kafka-connect.yaml`. If you created the ConfigMap in the previous step to filter out `accesskey` and `secretkey` values from the logs, uncomment the `spec.logging` lines to allow for the custom logging filters to be enabled during Kafka Connect cluster creation. Then this resource can be created via `kubectl apply -f kafka-connect.yaml`. You can then tail the output of the `connect-cluster-101` pods for updates on the connector status.\n\n#### Build the Camel Kafka Connector\n\nThe next step is to build the Camel Kafka Connector binaries so that they can be loaded into the just-deployed Kafka Connect cluster's container images.\n\n1. Clone the repository https://github.com/osowski/camel-kafka-connector to your local machine:\n   - `git clone https://github.com/osowski/camel-kafka-connector.git`\n2. Check out the `camel-kafka-connector-0.1.0-branch`:\n   - `git checkout camel-kafka-connector-0.1.0-branch`\n3. From the root directory of the repository, build the project components:\n   - `mvn clean package`\n4. Go get a coffee and take a walk... as this build will take around 30 minutes on a normal developer workstation.\n   - To reduce the overall build scope of the project, you can comment out the undesired modules from the `<modules>` element of the `connectors/pom.xml` using `<!-- -->` notation.\n5. Copy the generated S3 artifacts to the core package build artifacts:\n   - `cp connectors/camel-aws-s3-kafka-connector/target/camel-aws-s3-kafka-connector-0.1.0.jar core/target/camel-kafka-connector-0.1.0-package/share/java/camel-kafka-connector/`\n\nSome items to note:\n- The repository used here (https://github.com/osowski/camel-kafka-connector) is a fork of the official repository (https://github.com/apache/camel-kafka-connector) with a minor update applied to allow for dynamic endpoints to be specified via configuration, which is critical for our [Kafka to S3 Sink Connector](#kafka-to-s3-sink-connector) scenario.\n- This step (and the next step) will eventually be eliminated by providing an existing container image with the necessary Camel Kafka Connector binaries as part of a build system.\n\n#### Deploy the Camel Kafka Connector binaries\n\nNow that the Camel Kafka Connector binaries have been built, we need to include them on the classpath inside of the container image which our Kafka Connect clusters are using.\n\n1. From the root directory of the repository, start a new OpenShift Build, using the generated build artifacts:\n   ```shell\n   oc start-build connect-cluster-101-connect --from-dir=./core/target/camel-kafka-connector-0.1.0-package/share/java --follow\n   ```\n2. Watch the Kubernetes pods as they are updated with the new build and rollout of the Kafka Connect Cluster using the updated container image _(which now includes the Camel Kafka Connector binaries)_:\n   ```shell\n   kubectl get pods -w\n   ```\n3. Once the `connect-cluster-101-connect-2-[random-suffix]` pod is in a `Running` state, you can proceed.\n\n## Kafka to S3 Sink Connector\n\nNow that you have a Kafka Connect cluster up and running, you will need to configure a connector to actually begin the transmission of data from one system to the other. This will be done by taking advantage of Strimzi and using the [`KafkaConnector` custom resource](https://strimzi.io/docs/0.17.0/#kafkaconnector_resources) the Strimzi Operator manages for us.\n\nReview the YAML description for our `KafkaConnector` custom resource below, named `s3-sink-connector`. Pay close attention to:\n- The `strimzi.io/cluster` label must match the deployed Kafka Connect cluster you previously deployed _(or else Strimzi will not connect the `KafkaConnector` to your `KafkaConnect` cluster)_\n- The `topics` parameter _(named `my-source-topic` here)_\n- The S3 Bucket parameter of the `camel.sink.url` configuration option _(named `my-s3-bucket` here)_\n\n```yaml\napiVersion: kafka.strimzi.io/v1alpha1\nkind: KafkaConnector\nmetadata:\n  name: s3-sink-connector\n  labels:\n    strimzi.io/cluster: connect-cluster-101\nspec:\n  class: org.apache.camel.kafkaconnector.CamelSinkConnector\n  tasksMax: 1\n  config:\n    key.converter: org.apache.kafka.connect.storage.StringConverter\n    value.converter: org.apache.kafka.connect.storage.StringConverter\n    topics: my-source-topic\n    camel.sink.url: aws-s3://my-s3-bucket?keyName=${date:now:yyyyMMdd-HHmmssSSS}-${exchangeId}\n    camel.sink.maxPollDuration: 10000\n    camel.component.aws-s3.configuration.autocloseBody: false\n    camel.component.aws-s3.accessKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_access_key_id}\n    camel.component.aws-s3.secretKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_secret_access_key}\n    camel.component.aws-s3.region: US_EAST_1\n```\n\nOnce you have updated the YAML and saved it in a file named `kafka-sink-connector.yaml`, this resource can be created via `kubectl apply -f kafka-sink-connector.yaml`. You can then tail the output of the `connect-cluster-101` pods for updates on the connector status.\n\n**NOTE:** If you require objects in S3 to reside in a sub-folder of the bucket root, you can place a folder name prefix in the `keyName` query parameter of the `camel.sink.url` configuration option above. For example, `camel.sink.url: aws-s3://my-s3-bucket?keyName=myfoldername/${date:now:yyyyMMdd-HHmmssSSS}-${exchangeId}`.\n\n## S3 to Kafka Source Connector\n\nSimilar to the [Kafka to S3 Sink Connector](#kafka-to-s3-sink-connector) scenario, this scenario will make use of the Strimzi [`KafkaConnector` custom resource](https://strimzi.io/docs/0.17.0/#kafkaconnector_resources) to configure the specific connector instance.\n\nReview the YAML description for our `KafkaConnector` custom resource below, named `s3-source-connector`. Pay close attention to:\n- The `strimzi.io/cluster` label must match the deployed Kafka Connect cluster you previously deployed _(or else Strimzi will not connect the `KafkaConnector` to your `KafkaConnect` cluster)_\n- The `topics` and `camel.source.kafka.topic` parameters _(named `my-target-topic` here)_\n- The S3 Bucket parameter of the `camel.sink.url` configuration option _(named `my-s3-bucket` here)_\n\n**Please note** that it is an explicit intention that the topics used in the [Kafka to S3 Sink Connector](#kafka-to-s3-sink-connector) configuration and the [S3 to Kafka Source Connector](#s3-to-kafka-source-connector) configuration are different. If these configurations were to use the **same Kafka topic** and the **same S3 Bucket**, we would create an infinite processing loop of the same information being endlessly recycled through the system. In our example deployments here, we are deploying to different topics but the same S3 Bucket.\n\n```yaml\napiVersion: kafka.strimzi.io/v1alpha1\nkind: KafkaConnector\nmetadata:\n  name: s3-source-connector\n  labels:\n    strimzi.io/cluster: connect-cluster-101\nspec:\n  class: org.apache.camel.kafkaconnector.CamelSourceConnector\n  tasksMax: 1\n  config:\n    key.converter: org.apache.kafka.connect.storage.StringConverter\n    value.converter: org.apache.camel.kafkaconnector.awss3.converters.S3ObjectConverter\n    topics: my-target-topic\n    camel.source.kafka.topic: my-target-topic\n    camel.source.url: aws-s3://my-s3-bucket?autocloseBody=false\n    camel.source.maxPollDuration: 10000\n    camel.component.aws-s3.accessKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_access_key_id}\n    camel.component.aws-s3.secretKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_secret_access_key}\n    camel.component.aws-s3.region: US_EAST_1\n```\n\nOnce you have updated the YAML and saved it in a file named `kafka-source-connector.yaml`, this resource can be created via `kubectl apply -f kafka-source-connector.yaml`. You can then tail the output of the `connect-cluster-101` pods for updates on the connector status.\n\n**NOTE:** If you require the connector to only read objects from a subdirecotry of the S3 bucket root, you can set the `camel.component.aws-s3.configuration.prefix` configuration option with the value of the subdirectory name. For example, `camel.component.aws-s3.configuration.prefix: myfoldername` .\n\n\n## Event Streams v10 Addendum\n\n- The steps up to now assumed usage of an OpenShift Container Platform v4.3.x cluster, IBM Cloud Pak for Integration v2020.1.1 and IBM Event Streams v2019.4.2\n- With the release of Event Streams v10 (which is built on top of the Strimzi Kafka Operator) and the new CP4I there are some things need that need to be adjusted in the yamls to reflect that.\n\n- You can edit the previous `kafka-connect.yaml` or create a new file.\n**kafka-connect-esv10.yaml**\n```yaml\napiVersion: eventstreams.ibm.com/v1beta1\nkind: KafkaConnectS2I\nmetadata:\n  name: connect-cluster-101\n  annotations:\n    eventstreams.ibm.com/use-connector-resources: \"true\"\nspec:\n  #logging:\n  #  type: external\n  #  name: custom-connect-log4j\n  version: 2.5.0\n  replicas: 1\n  bootstrapServers: {internal-bootstrap-server-address}\n  template:\n    pod:\n      imagePullSecrets: []\n      metadata:\n        annotations:\n          eventstreams.production.type: CloudPakForIntegrationNonProduction\n          productID: {product-id}\n          productName: IBM Event Streams for Non Production\n          productVersion: 10.0.0\n          productMetric: VIRTUAL_PROCESSOR_CORE\n          productChargedContainers: {connect-cluster-101}-connect\n          cloudpakId: {cloudpak-id}\n          cloudpakName: IBM Cloud Pak for Integration\n          cloudpakVersion: 2020.2.1\n          productCloudpakRatio: \"2:1\"\n  tls:\n      trustedCertificates:\n        - secretName: {your-es-instance-name}-cluster-ca-cert\n          certificate: ca.crt\n  authentication:\n    type: tls\n    certificateAndKey:\n      certificate: user.crt\n      key: user.key\n      secretName: {generated-secret-from-ui}\n  externalConfiguration:\n    volumes:\n      - name: aws-credentials\n        secret:\n          secretName: aws-credentials\n  config:\n    group.id: connect-cluster-101\n    config.providers: file\n    config.providers.file.class: org.apache.kafka.common.config.provider.FileConfigProvider\n    key.converter: org.apache.kafka.connect.json.JsonConverter\n    value.converter: org.apache.kafka.connect.json.JsonConverter\n    key.converter.schemas.enable: false\n    value.converter.schemas.enable: false\n    offset.storage.topic: connect-cluster-101-offsets\n    config.storage.topic: connect-cluster-101-configs\n    status.storage.topic: connect-cluster-101-status\n```\n\n- There are a couple changes of note here.\n  - `apiVersion: eventstreams.ibm.com/v1beta1` instead of the previous Strimzi one.\n  - `metadata.annotations.eventstreams.ibm.com/use-connector-resources: \"true\"` instead of the previous Strimzi one as well.\n  - `spec.bootstrapservers:` Previously in Event Streams v2019.4.2 and prior there was only a single external facing route for this bootstrap server address. In Event Streams v10 there is an `External` and `Internal` one now. Replace `{internal-bootstrap-server-address}` with the `Internal` bootstrap server address from the Event Streams v10 UI.\n  - `spec.template.pod.metadata.annotations.*` This entire section is new and represents new metadata that the Event Streams instance needs.\n  - `spec.template.pod.metadata.annotations.productID` You can find this value when trying to deploy an Event Streams Custom Resource from the Installed Event Streams Operator YAML deployment or when applying this YAML through the command-line, OCP will provide you the proper values if they're wrong.\n  - `spec.template.pod.metadata.annotations.cloudpakId` Same as productID.\n  - `spec.tls.trustedCertificates` This is different from the previous one in that this certificate was automatically generated on creation of your Event Streams Kafka Cluster. If your Event Streams instance is named `eventstreams-dev` then this value should be `eventstreams-dev-cluster-ca-cert`.\n  - `spec.authentication.*` This section is mostly different from the previous section. Prior we used a generated API Key, but on Event Streams v10 we will need to generate TLS credentials. In the `Internal` connection details there will be a `Generate TLS Credentials` button. Here you can name your secret and provide the proper access to it. **Note 1** - This is automatically created by the Event Streams Operator into the same namespace as both a `KafkaUser` Custom Resource as well as a secret. If your secret is named `internal-secret` then there will be an automatically generated Kubernetes/OpenShift secret named that as well as a `KafkaUser`. `user.crt` and `user.key` are certificates automatically generated within said secret. **Note 2** - Deletion of that secret will replicate itself. You will need to delete the associated and created `KafkaUser`.\n\n**kafka-sink-connector.yaml-esv10.yaml**\n```yaml\napiVersion: eventstreams.ibm.com/v1alpha1\nkind: KafkaConnector\nmetadata:\n  name: s3-sink-connector\n  labels:\n    eventstreams.ibm.com/cluster: connect-cluster-101\nspec:\n  class: org.apache.camel.kafkaconnector.CamelSinkConnector\n  tasksMax: 1\n  config:\n    key.converter: org.apache.kafka.connect.storage.StringConverter\n    value.converter: org.apache.kafka.connect.storage.StringConverter\n    topics: my-topic\n    camel.sink.url: aws-s3://my-s3-bucket?keyName=${date:now:yyyyMMdd-HHmmssSSS}-${exchangeId}\n    camel.sink.maxPollDuration: 10000\n    camel.component.aws-s3.configuration.autocloseBody: false\n    camel.component.aws-s3.accessKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_access_key_id}\n    camel.component.aws-s3.secretKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_secret_access_key}\n    camel.component.aws-s3.region: my-s3-bucket-region\n```\n- For the most part identical besides two minor changes.\n  - `apiVersion: eventstreams.ibm.com/v1alpha1` instead of Strimzi.\n  - `metadata.labels.eventstreams.ibm.com/cluster: connect-cluster-101` again instead of Strimzi.\n\n**kafka-source-connector.yaml-esv10.yaml**\n```yaml\napiVersion: eventstreams.ibm.com/v1alpha1\nkind: KafkaConnector\nmetadata:\n  name: s3-source-connector\n  labels:\n    eventstreams.ibm.com/cluster: connect-cluster-101\nspec:\n  class: org.apache.camel.kafkaconnector.CamelSourceConnector\n  tasksMax: 1\n  config:\n    key.converter: org.apache.kafka.connect.storage.StringConverter\n    value.converter: org.apache.camel.kafkaconnector.awss3.converters.S3ObjectConverter\n    topics: my-topic\n    camel.source.kafka.topic: my-topic\n    camel.source.url: aws-s3://my-s3-bucket?autocloseBody=false\n    camel.source.maxPollDuration: 10000\n    camel.component.aws-s3.accessKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_access_key_id}\n    camel.component.aws-s3.secretKey: ${file:/opt/kafka/external-configuration/aws-credentials/aws-credentials.properties:aws_secret_access_key}\n    camel.component.aws-s3.region: my-s3-bucket-region\n```\n- Similar to the S3 sink connector yaml.\n  - `apiVersion: eventstreams.ibm.com/v1alpha1` instead of Strimzi.\n  - `metadata.labels.eventstreams.ibm.com/cluster: connect-cluster-101` again instead of Strimzi.\n\n\n\n## Troubleshooting\n\n* The log output from the Kafka Connector instances will be available in the KafkaConnectS2I pods, named in the pattern of `{connect-cluster-name}-connect-{latest-build-id}-{random-suffix}`. This pattern will be referred to as `{connect-pod}` throughout the rest of the **Troubleshooting** section.\n\n\n* To increase the logging output of the deployed connector instances:\n  - Follow the steps for **\"Create ConfigMap for log4j configuration\"** in [Kafka Connect Cluster](#kafka-connect-cluster) above\n  - Update the `log4j.properties` ConfigMap to include the line `log4j.logger.org.apache.camel.kafkaconnector=DEBUG`\n  - Reapply the YAML configuration of the KafkaConnectS2I cluster\n\n\n* To check the deployment status of applied Kafka Connect configuration via Kafka Connect's REST API, run the following commands:\n  - `oc exec {connect-pod} bash -- -c \"curl --silent http://localhost:8083/connectors/\"`\n  - `oc exec {connect-pod} bash -- -c \"curl --silent http://localhost:8083/connectors/{deployed-connector-name}/status\"`\n\n## Next steps\n\n- Enable use  of IAM Credentials in the Connector configuration _(as the default Java code currently outputs `aws_access_key_id` and `aws_secret_access_key` to container runtime logs due to their existence as configuration properties)_\n- Optionally configure individual connector instances to startup with offset value of -1 _(to enable to run from beginning of available messages)_\n- Implement a build system to produce container images with the Camel Kafka Connector binaries already present\n\n## References\n- [Apache Camel Kafka Connector - Try it out on OpenShift with Strimzi](https://camel.apache.org/camel-kafka-connector/latest/try-it-out-on-openshift-with-strimzi.html)\n- [Apache Camel - Available pattern elements](https://camel.apache.org/components/latest/languages/simple-language.html) for use in the `keyName` parameter of the `camel.sink.url` property.\n- [Apache Camel - Dynamic Endpoint reference](https://camel.apache.org/components/latest/eips/toD-eip.html)\n- [Red Hat Developer Blog - Using secrets in Kafka Connect configuration](https://developers.redhat.com/blog/2020/02/14/using-secrets-in-apache-kafka-connect-configuration/)\n- [Apache Kafka - Connect Overview](http://kafka.apache.org/documentation/#connect)\n","fileAbsolutePath":"/home/runner/work/refarch-eda/refarch-eda/docs/src/pages/use-cases/connect-s3/index.mdx"}}},"staticQueryHashes":["1054721580","1054721580","1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","768070550"]}