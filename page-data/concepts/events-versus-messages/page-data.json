{"componentChunkName":"component---src-pages-concepts-events-versus-messages-index-mdx","path":"/concepts/events-versus-messages/","result":{"pageContext":{"frontmatter":{"title":"Event Streaming versus Queuing","description":"Comparing and contrasting events and messages as communication artifacts in distributed systems."},"relativePagePath":"/concepts/events-versus-messages/index.mdx","titleType":"append","MdxNode":{"id":"d9302f03-504e-5f49-a8ea-e86d7d9bc17c","children":[],"parent":"cf9f4233-2844-5d8d-b2c5-a84bcc156880","internal":{"content":"---\ntitle: Event Streaming versus Queuing\ndescription: Comparing and contrasting events and messages as communication artifacts in distributed systems.\n---\n\n## MQ Versus Kafka\n\nConsider queue system. like IBM MQ, for:\n\n* Exactly once delivery, and to participate into two phase commit transaction\n* Asynchronous request / reply communication: the semantic of the communication is for one component to ask a second command to do something on its data. This is a command pattern with delay on the response.\n* Recall messages in queue are kept until consumer(s) got them.\n\nConsider Kafka as pub/sub and persistence system for:\n\n* Publish events as immutable facts of what happen in an application\n* Get continuous visibility of the data Streams\n* Keep data once consumed, for future consumers, for replay-ability\n* Scale horizontally the message consumption\n\n### Direct product feature comparison\n\n| Kafka | IBM MQ | \n| --- | --- |\n| Kafka is a pub/sub engine with streams and connectors | MQ is a queue, pub/sub engine with file transfer, MQTT, AMQP and other capabilities |\n| All topics are persistent \u000b | Queues and topics can be persistent or non persistent |\n| All subscribers are durable | Subscribers can be durable or non durable |\n| Adding brokers to requires little work (changing a configuration file)\u000b\u000b| Adding QMGRs requires some work (Add the QMGRs to the cluster, add cluster channels.  Queues and Topics need to be added to the cluster.) |\n| Topics can be spread across brokers (partitions) with a command\u000b | Queues and topics can be spread across a cluster by adding them to clustered QMGRs |\n| Producers and Consumers are aware of changes made to the cluster | All MQ clients require a CCDT file to know of changes if not using a gateway QMGR |\n| Can have n number of replication partitions | Can have 2 replicas (RDQM) of a QMGR, Multi Instance QMGRs |\n| Simple load balancing\u000b | Load balancing can be simple or more complex using weights and affinity |\n| Can reread messages\u000b | Cannot reread messages that have been already processed | \n| All clients connect using a single connection method | MQ has Channels which allow different clients to connect, each having the ability to have different security requirements | \n| Data Streams processing built in, using Kafka topic for efficiency| Stream processing is not built in, but using third party libraries, like MicroProfile Reactive Messaging, ReactiveX, etc. |\n| Has connection security, authentication security, and ACLs (read/write to Topic) | Has connection security, channel security, authentication security, message security/encryption, ACLs for each Object, third party plugins (Channel Exits) |\n| Built on Java, so can run on any platform that support Java 8+ | Latest native on AIX, IBM i, Linux systems, Solaris, Windows, z/OS, run as Container | \n| Monitoring by using statistics provided by Kafka CLI, open source tools, Prometheus | Monitoring using PCF API, MQ Explorer, MQ CLI (runmqsc), Third Party Tools (Tivoli, CA APM, Help Systems, Open Source, etc) |\n\n\n## Events and Messages\n\nThere is a long history of *messaging* in IT systems.  You can easily see an event driven solution and events in the context of messaging systems and messages. However, there are different characteristics that are worth considering:\n\n* **Messaging:** Messages transport a payload and messages are persisted until consumed. Message consumers are typically directly targeted and related to the producer who cares that the message has been delivered and processed.\n* **Events:** Events are persisted as a replayable stream history. Event consumers are not tied to the producer. An event is a record of something that has happened and so can't be changed. (You can't change history.)\n\n![](./images/evt-msg.png)\n\n## Messaging versus event streaming\n\nWe recommend reading [this article](https://developer.ibm.com/messaging/2018/05/18/comparing-messaging-event-streaming-use-cases/) and [this one](https://developer.ibm.com/messaging/2019/02/05/comparing-messaging-pub-sub-and-event-streams/), to get insight on messaging (focusing on operations / actions to be performed by a system or service) versus events (focusing on the state / facts of a system with no knowledge of the downstream processing).\n\nTo summarize messaging (like MQ) are to support:\n\n* **Transient Data:** data is only stored until a consumer has processed the message, or it expires.\n* **Request / reply** most of the time.\n* **Targeted reliable delivery:** targeted to the entity that will process the request or receive the response. Reliable with transaction support.\n* **Highly Coupled** producers and consumers\n\nFor events:\n\n* **Stream History:** consumers are interested in historic events, not just the most recent.\n* **Scalable Consumption:** A single event is consumed by many consumers with limited impact as the number of consumers grow.\n* **Immutable Data**\n* **Loosely coupled / decoupled** producers and consumers\n\nSee also the [MQ in Event Driven Solution context](/technology/mq/)\n\nSee [this code (Store sale simulator)](https://github.com/ibm-cloud-architecture/refarch-eda-store-simulator) to produce to different middleware: RabbitMQ, IBM MQ or Kafka.","type":"Mdx","contentDigest":"0fe6bf65e92fa6838814e8aeb718c050","owner":"gatsby-plugin-mdx","counter":671},"frontmatter":{"title":"Event Streaming versus Queuing","description":"Comparing and contrasting events and messages as communication artifacts in distributed systems."},"exports":{},"rawBody":"---\ntitle: Event Streaming versus Queuing\ndescription: Comparing and contrasting events and messages as communication artifacts in distributed systems.\n---\n\n## MQ Versus Kafka\n\nConsider queue system. like IBM MQ, for:\n\n* Exactly once delivery, and to participate into two phase commit transaction\n* Asynchronous request / reply communication: the semantic of the communication is for one component to ask a second command to do something on its data. This is a command pattern with delay on the response.\n* Recall messages in queue are kept until consumer(s) got them.\n\nConsider Kafka as pub/sub and persistence system for:\n\n* Publish events as immutable facts of what happen in an application\n* Get continuous visibility of the data Streams\n* Keep data once consumed, for future consumers, for replay-ability\n* Scale horizontally the message consumption\n\n### Direct product feature comparison\n\n| Kafka | IBM MQ | \n| --- | --- |\n| Kafka is a pub/sub engine with streams and connectors | MQ is a queue, pub/sub engine with file transfer, MQTT, AMQP and other capabilities |\n| All topics are persistent \u000b | Queues and topics can be persistent or non persistent |\n| All subscribers are durable | Subscribers can be durable or non durable |\n| Adding brokers to requires little work (changing a configuration file)\u000b\u000b| Adding QMGRs requires some work (Add the QMGRs to the cluster, add cluster channels.  Queues and Topics need to be added to the cluster.) |\n| Topics can be spread across brokers (partitions) with a command\u000b | Queues and topics can be spread across a cluster by adding them to clustered QMGRs |\n| Producers and Consumers are aware of changes made to the cluster | All MQ clients require a CCDT file to know of changes if not using a gateway QMGR |\n| Can have n number of replication partitions | Can have 2 replicas (RDQM) of a QMGR, Multi Instance QMGRs |\n| Simple load balancing\u000b | Load balancing can be simple or more complex using weights and affinity |\n| Can reread messages\u000b | Cannot reread messages that have been already processed | \n| All clients connect using a single connection method | MQ has Channels which allow different clients to connect, each having the ability to have different security requirements | \n| Data Streams processing built in, using Kafka topic for efficiency| Stream processing is not built in, but using third party libraries, like MicroProfile Reactive Messaging, ReactiveX, etc. |\n| Has connection security, authentication security, and ACLs (read/write to Topic) | Has connection security, channel security, authentication security, message security/encryption, ACLs for each Object, third party plugins (Channel Exits) |\n| Built on Java, so can run on any platform that support Java 8+ | Latest native on AIX, IBM i, Linux systems, Solaris, Windows, z/OS, run as Container | \n| Monitoring by using statistics provided by Kafka CLI, open source tools, Prometheus | Monitoring using PCF API, MQ Explorer, MQ CLI (runmqsc), Third Party Tools (Tivoli, CA APM, Help Systems, Open Source, etc) |\n\n\n## Events and Messages\n\nThere is a long history of *messaging* in IT systems.  You can easily see an event driven solution and events in the context of messaging systems and messages. However, there are different characteristics that are worth considering:\n\n* **Messaging:** Messages transport a payload and messages are persisted until consumed. Message consumers are typically directly targeted and related to the producer who cares that the message has been delivered and processed.\n* **Events:** Events are persisted as a replayable stream history. Event consumers are not tied to the producer. An event is a record of something that has happened and so can't be changed. (You can't change history.)\n\n![](./images/evt-msg.png)\n\n## Messaging versus event streaming\n\nWe recommend reading [this article](https://developer.ibm.com/messaging/2018/05/18/comparing-messaging-event-streaming-use-cases/) and [this one](https://developer.ibm.com/messaging/2019/02/05/comparing-messaging-pub-sub-and-event-streams/), to get insight on messaging (focusing on operations / actions to be performed by a system or service) versus events (focusing on the state / facts of a system with no knowledge of the downstream processing).\n\nTo summarize messaging (like MQ) are to support:\n\n* **Transient Data:** data is only stored until a consumer has processed the message, or it expires.\n* **Request / reply** most of the time.\n* **Targeted reliable delivery:** targeted to the entity that will process the request or receive the response. Reliable with transaction support.\n* **Highly Coupled** producers and consumers\n\nFor events:\n\n* **Stream History:** consumers are interested in historic events, not just the most recent.\n* **Scalable Consumption:** A single event is consumed by many consumers with limited impact as the number of consumers grow.\n* **Immutable Data**\n* **Loosely coupled / decoupled** producers and consumers\n\nSee also the [MQ in Event Driven Solution context](/technology/mq/)\n\nSee [this code (Store sale simulator)](https://github.com/ibm-cloud-architecture/refarch-eda-store-simulator) to produce to different middleware: RabbitMQ, IBM MQ or Kafka.","fileAbsolutePath":"/home/runner/work/refarch-eda/refarch-eda/docs/src/pages/concepts/events-versus-messages/index.mdx"}}},"staticQueryHashes":["1054721580","1054721580","1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","768070550"]}