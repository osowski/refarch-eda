(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{UYxO:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return o})),a.d(t,"default",(function(){return l}));a("91GP"),a("rGqo"),a("yt8O"),a("Btvt"),a("RW0V"),a("q1tI");var n=a("7ljp"),i=a("013z");a("qKvR");function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}var o={},s={_frontmatter:o},c=i.a;function l(e){var t=e.components,a=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,["components"]);return Object(n.b)(c,r({},s,a,{components:t,mdxType:"MDXLayout"}),Object(n.b)("p",null,"!!! abstract\nIn this article, we are detailing some of the most import event-driven patterns to be used during your microservice implementation and when adopting kafka as an event backbone."),Object(n.b)("p",null,"Adopting messaging (Pub/Sub) as a microservice communication backbone involves using at least the following patterns:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",r({parentName:"li"},{href:"https://microservices.io/patterns/decomposition/decompose-by-subdomain.html"}),"Decompose by subdomain"),", event driven microservices are still microservices, so we need to find them, and the domain-driven subdomains is a good approach to identify and classify business function and therefore microservices. With the event storming method, aggregates help to find those subdomain of responsibility. "),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",r({parentName:"li"},{href:"https://microservices.io/patterns/data/database-per-service.html"}),"Database per service")," to enforce each service persists data privately and is accessible only via its API. Services are loosely coupled limiting impact to other service when database schema changes. The database technology is selected from business requirements. The implementation of transactions that span multiple services is complex and enforce using the Saga pattern. Queries that goes over multiple entities is a challenge and CQRS represents an interesting solution. "),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",r({parentName:"li"},{href:"#strangler-pattern"}),"Strangler pattern")," is used to incrementally migrate an existing, monolytic application by replacing a set of features to a microservice but keep both running in parallel. Applying a domain driven design approach, you may strangle the application using bounded context. But then aS soon as this pattern is applied, you need to assess the co-existence between existing bounded contexts and the new microservices. One of the challenges will be to define where the write and read operations occurs, and how data should be replicated between the contexts. This is where event driven architecture helps. "),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",r({parentName:"li"},{href:"event-sourcing.md"}),"Event sourcing")," persists the state of a business entity such an Order as a sequence of state-changing events. "),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",r({parentName:"li"},{href:"cqrs.md"}),"Command Query Responsibility Segregation")," helps to separate queries from commands and help to address queries with cross-microservice boundary."),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",r({parentName:"li"},{href:"saga.md"}),"Saga pattern:")," Microservices publish events when something happens in the scope of their control like an update in the business entities they are responsible for. A microservice interested in other business entities, subscribe to those events and it can update its own states and business entities when receiving such events. Business entity keys needs to be unique, immutable."),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",r({parentName:"li"},{href:"#event-reprocessing-with-dead-letter-pattern"}),"Event reprocessing with dead letter"),": event driven microservice may have to call external service via synchronous call, we need to process failure to get response from those service, using event backbone."),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",r({parentName:"li"},{href:"https://microservices.io/patterns/data/transactional-outbox.html"}),"Transactional outbox"),": A service command typically needs to update the database and send messages/events. The approach is to use a outbox table to keep the message to sent and a message relay process to publish events inserted into database to the event backbone.")),Object(n.b)("h2",null,"Strangler pattern"),Object(n.b)("h3",null,"Problem"),Object(n.b)("p",null,"How to migrate a monolytics application to microservice without doing a big bang, redeveloping the application from white page. Replacing and rewritting an existing application can be a huge investment. Rewritting a subset of business functions while running current application in parallel may be relevant and reduce risk and velocity of changes. "),Object(n.b)("h3",null,"Solution"),Object(n.b)("p",null,"The approach is to use a “strangler” interface to dispatch request to new or old features. Existing features to migrate are selected by trying to isolate sub components. "),Object(n.b)("p",null,"One of main challenge is to isolate data store and how the new microservices and the legacy application are accessing the shared data. Continuous data replication can be a solution to propagate write model to read model. Write model will most likely stays on the monolitic application, change data capture can be used, with event backbone to propagate change to read model."),Object(n.b)("p",null,"The facade needs to be scalable and not a single point of failure. It needs to support new APIs (RESTful) and old API (most likely SOAP)."),Object(n.b)("h2",null,"Event reprocessing with dead letter pattern"),Object(n.b)("p",null,"With event driven microservice, it is not just about pub/sub. There are use cases where the microservice needs to call existing service via an HTTP or RPC call. The call may fail. So what should be the processing to be done to retry and gracefully fail by leveraging the power of topics and the concept of dead letter."),Object(n.b)("p",null,"This pattern is influenced by the adoption of Kafka as event backbone and the offset management offered by Kafka. Once a message is read from a Kafka topic by a consumer the offset can be automatically committed so the consumer can poll the next batch of events, or in most the case manually committed, to support business logic to process those events. "),Object(n.b)("p",null,"The figure below demonstrates the problem to address: the ",Object(n.b)("inlineCode",{parentName:"p"},"reefer management microservice")," get order event to process by allocating a reefer container to the order. The call to update the container inventory fails."),Object(n.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"1152px"}},"\n      ",Object(n.b)("span",r({parentName:"span"},{className:"gatsby-resp-image-background-image",style:{paddingBottom:"43.40277777777778%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABeklEQVQoz4WSTW+CQBCG/f8/oKem8WIvTZPePPZgrVWbpoptFPELFAQU8QOBBfbt7FK1baKdZJhl2Dz7vrMUOOcQIQvP66EnIkk5vM0eaZoho3ZG35y5B2NsYzZxYE5tpCz6ZnAUxCKMYnwoGtrvKjrtPrTBGH3Dhb+NkBLlSTEQEozYYPTo9Qd4ayloKZ94bXVQ7+qYensJlUBGp490Hbqho6uN4NgzVDo67mojbFkmpWcTXapN6DUIY2yCEFEUYb0LcP+i4blr5cCFv0NXX5KtEKqxlE1/G6I381FRXSx2jHgZuOdJSz+m8Sd4bjmIElgk1w8Y7FUuW5utMLXX+baMZke2hU4xP7mWvVOe7oGA5tyG5biIYgbLtjEka/twj5gliJMUjDwyWc9nzNIjtFCpN3BVLKLabOChXMbN7S2uSyU8VqtHK/+FgB6BtUaTbqwNl2ZkmCYGkwnU4RAmqRV70oPlC/lLoe+vZZOfOTkhy5dS7BH/6GGGX+CtsjgU8cY7AAAAAElFTkSuQmCC')",backgroundSize:"cover",display:"block"}})),"\n  ",Object(n.b)("img",r({parentName:"span"},{className:"gatsby-resp-image-image",alt:"Dead letter context",title:"Dead letter context",src:"/refarch-eda/static/f424461dec2385d2ab5d41cf08d44327/3cbba/dl-1.png",srcSet:["/refarch-eda/static/f424461dec2385d2ab5d41cf08d44327/7fc1e/dl-1.png 288w","/refarch-eda/static/f424461dec2385d2ab5d41cf08d44327/a5df1/dl-1.png 576w","/refarch-eda/static/f424461dec2385d2ab5d41cf08d44327/3cbba/dl-1.png 1152w","/refarch-eda/static/f424461dec2385d2ab5d41cf08d44327/3ff9f/dl-1.png 1166w"],sizes:"(max-width: 1152px) 100vw, 1152px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"})),"\n    "),Object(n.b)("p",null,"At first glance, the approach is to commit the offset only when the three internal operations are succesful: write to reefer database (2), update the container inventory using legacy application service (3), and produce new event to ",Object(n.b)("inlineCode",{parentName:"p"},"orders")," (4) and ",Object(n.b)("inlineCode",{parentName:"p"},"containers")," (5) topics. Step (4) and (5) will not be done as no response from (3) happened. "),Object(n.b)("p",null,"In fact a better approach is to commit the read offset on the orders topic, and then starts the processing: the goal is to do not impact the input throughput. In case of step (2) or (3) fails the order data is published to an ",Object(n.b)("inlineCode",{parentName:"p"},"order-retries")," topic (4) with some added metadata like number of retries and timestamp."),Object(n.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"1152px"}},"\n      ",Object(n.b)("span",r({parentName:"span"},{className:"gatsby-resp-image-background-image",style:{paddingBottom:"46.52777777777778%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABvklEQVQoz3VRTW/TQBD1//8HSJxauLSigh6qVkKlBwKkiuUkJUmtusWKk8b22vE6/v5YP2Y32AcQI412d2Zn5r03Gsi6rsP/bMi5LmoWQr5E26IsKvJanW3bDP+1viBLC6x/uXCk2y6CfYRDXqvc845jaW5AlSgEsHVDjL9PoU8ecD+e4dF6QVbWargm/jQMoxi6Mcf85xLG7AGrJwsfv1mwWYqmFYjzCmnVoqHvh6wA4xHcMKTBAa4NG2djG0XVQJPNAp6BxbkkiIDOsjoiu1u5uJpu1H3rx1jY7CiDdD+AqFv1zssKcZIfEcqA4x+w9hOVnJguCpIkSkro5k7FGOOYz15grmwEYQShggFJ0PyjuaboxDHSokTVCPCYw9l5cPcJWJTAefVIMx8Xnyd49aiZ6MAPCTa+jyTLUTctKkLaS6fJwNXtLU4/XMB2NvgyGuHNySmebZtAMJycnxMdQt+JYeP3hoG3797j7PISn65vFGWVkpSTNMPd1xF+6Dr2Ecd6u8V0scCec6SE4NGyaLlC6dYKRZaQepgvV1iYJi3viTRvhmFaQVQ9jw1FvREzanCMSFkkk/7822Ssb/gb3Y6qOgnN//YAAAAASUVORK5CYII=')",backgroundSize:"cover",display:"block"}})),"\n  ",Object(n.b)("img",r({parentName:"span"},{className:"gatsby-resp-image-image",alt:"Dead letter context",title:"Dead letter context",src:"/refarch-eda/static/e192f384eee9637f08aa319ccf3cdc0a/3cbba/dl-2.png",srcSet:["/refarch-eda/static/e192f384eee9637f08aa319ccf3cdc0a/7fc1e/dl-2.png 288w","/refarch-eda/static/e192f384eee9637f08aa319ccf3cdc0a/a5df1/dl-2.png 576w","/refarch-eda/static/e192f384eee9637f08aa319ccf3cdc0a/3cbba/dl-2.png 1152w","/refarch-eda/static/e192f384eee9637f08aa319ccf3cdc0a/c95a1/dl-2.png 1162w"],sizes:"(max-width: 1152px) 100vw, 1152px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"})),"\n    "),Object(n.b)("p",null,"A new order retry service or function consumes the ",Object(n.b)("inlineCode",{parentName:"p"},"order retry")," events (5) and do a new call to the remote service using a delay according to the number of retry already done: this is to pace the calls to a service that has issue for longer time. If the call (6) fails this function creates a new event in the ",Object(n.b)("inlineCode",{parentName:"p"},"order-retries")," topic with a retry counter increased by one. If the number of retry reaches a certain threshold then the order is sent to ",Object(n.b)("inlineCode",{parentName:"p"},"order-dead-letter")," topic (7) for human to work on. A CLI could read from this dead letter topic to deal with the data, or retry automatically once we know the backend service works. Using this approach we delay the call to the remote service without putting too much preassure on it."),Object(n.b)("p",null,"We have implemented the dead letter pattern when integrating the container manager microservice with an external BPM end point. The ",Object(n.b)("a",r({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-kc/itg-tests/dlq/dlq/"}),"implementaton detail is in this note")," and the integration test ",Object(n.b)("a",r({parentName:"p"},{href:"https://github.com/ibm-cloud-architecture/refarch-kc/blob/master/itg-tests/es-it/ContainerAnomalyDlq.py"}),"here"),"."),Object(n.b)("p",null,"For more detail we recommend this article from Uber engineering: ",Object(n.b)("a",r({parentName:"p"},{href:"https://eng.uber.com/reliable-reprocessing/"}),"Building Reliable Reprocessing and Dead Letter Queues with Apache Kafka"),"."))}l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-design-patterns-ed-patterns-mdx-d75c4e5425b1b3829bb0.js.map