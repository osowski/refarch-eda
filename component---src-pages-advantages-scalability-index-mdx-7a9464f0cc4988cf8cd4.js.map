{"version":3,"sources":["webpack:///./src/pages/advantages/scalability/index.mdx"],"names":["name","_frontmatter","InlineNotification","props","console","warn","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","kind","isMDXComponent"],"mappings":"4LAQsBA,E,4DAFTC,G,UAAe,IAOtBC,GALgBF,EAKmB,qBALX,SAA6BG,GAEzD,OADAC,QAAQC,KAAK,cAAgBL,EAAO,4EAC7B,kBAASG,KAIZG,EAAc,CAClBL,gBAEIM,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGP,EACF,8BACD,OAAO,YAACI,EAAD,eAAeD,EAAiBH,EAAhC,CAAuCO,WAAYA,EAAYC,QAAQ,cAG5E,YAACT,EAAD,CAAoBU,KAAK,UAAUD,QAAQ,sBAAqB,kCAAhE,yBACA,qCACA,wdACA,sOACA,iOAKJF,EAAWI,gBAAiB","file":"component---src-pages-advantages-scalability-index-mdx-7a9464f0cc4988cf8cd4.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/refarch-eda/refarch-eda/docs/node_modules/gatsby-theme-carbon/src/templates/Default.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst InlineNotification = makeShortcode(\"InlineNotification\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <InlineNotification kind=\"warning\" mdxType=\"InlineNotification\"><strong>TODO</strong> - UNDER CONSTRUCTION</InlineNotification>\n    <h1>{`Scalability`}</h1>\n    <p>{`Event-Driven architectures are highly scalable. The use of an event-driven backbone allows for the addition (and removal) of consumers based on the number of messages waiting to be consumed from a topic. This is good for architectures where in-stream transformation is needed, like data science workflows. Messages can be consumed and transformed extremely fast, which is advantageous for processes where millisecond decision making is necessary. `}</p>\n    <p>{`When using a system like Kafka, the data (in a given topic) is partitioned by the broker, which allows for parallel processing of the data for consumpton. Consumers are usually assigned to one partition.  `}</p>\n    <p>{`As well as scaling up, there is also the ability to scale down (even to zero). When scaling up and down happens autonomously, promoting energy and cost efficiency, it is referred to as ‘elasticity’. `}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}