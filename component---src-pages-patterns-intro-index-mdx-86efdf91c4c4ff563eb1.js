(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{IG97:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return o})),n.d(t,"default",(function(){return l}));n("91GP"),n("rGqo"),n("yt8O"),n("Btvt"),n("RW0V"),n("q1tI");var a=n("7ljp"),i=n("013z");n("qKvR");function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var o={},r={_frontmatter:o},c=i.a;function l(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,["components"]);return Object(a.b)(c,s({},r,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",null,"Introduction"),Object(a.b)("p",null,"In this set of articles, we are detailing some of the most import event-driven patterns to be used during your event-driven microservice implementation."),Object(a.b)("p",null,"Adopting messaging (Pub/Sub) as a microservice communication approach involves using at least the following patterns:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",s({parentName:"li"},{href:"https://microservices.io/patterns/decomposition/decompose-by-subdomain.html"}),"Decompose by subdomain"),", event driven\nmicroservices are still microservices, so we need to find them, and the domain-driven subdomains is a good approach to identify and classify business\nfunction and therefore microservices. With the event storming method, aggregates help to find those subdomain of responsibility. (Source Chris Richardson - Microservices Patterns)"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",s({parentName:"li"},{href:"https://microservices.io/patterns/data/database-per-service.html"}),"Database per service")," to enforce each service persists data privately and is accessible only via its API.\nServices are loosely coupled limiting impact to other service when database schema changes. The database technology is selected from business requirements. (Source Chris Richardson - Microservices Patterns)\nThe implementation of transactions that span multiple services is complex and enforce using the Saga pattern. Queries that goes over multiple entities is a challenge and CQRS represents an interesting solution."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",s({parentName:"li"},{href:"#strangler-pattern"}),"Strangler pattern")," is used to incrementally migrate an existing, monolytic application by replacing a set of features to a microservice but keep both running in parallel.\nApplying a domain driven design approach, you may strangle the application using bounded context. But then as soon as this pattern is applied, you need to assess the co-existence between\nexisting bounded contexts and the new microservices. One of the challenges will be to define where the write and read operations occurs, and how data should be replicated between the contexts.\nThis is where event driven architecture helps."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",s({parentName:"li"},{href:"./event-sourcing/"}),"Event sourcing")," persists, to an append log, the states of a business entity, such an Order, as a sequence of immutable state-changing events."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",s({parentName:"li"},{href:"./cqrs/"}),"Command Query Responsibility Segregation")," helps to separate queries from commands and help to address queries with cross-microservice boundary."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",s({parentName:"li"},{href:"./saga/"}),"Saga pattern:")," Microservices publish events when something happens in the scope of their control like an update in the business entities they are responsible for. A microservice interested in other business entities, subscribe to those events and it can update its own states and business entities when receiving such events. Business entity keys needs to be unique, immutable."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",s({parentName:"li"},{href:"./dlq/"}),"Event reprocessing with dead letter"),": event driven microservice may have to call external service via synchronous call, we need to process failure to get response from those service, using event backbone."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",s({parentName:"li"},{href:"https://microservices.io/patterns/data/transactional-outbox.html"}),"Transactional outbox"),": A service command typically needs to update the database and send messages/events.\nThe approach is to use a outbox table to keep the message to sent and a message relay process to publish events inserted into database to the event backbone. (Source Chris Richardson - Microservices Patterns)")),Object(a.b)("h2",null,"Strangler pattern"),Object(a.b)("h3",null,"Problem"),Object(a.b)("p",null,"How to migrate a monolytics application to microservice without doing a big bang, redeveloping the application from white page.\nReplacing and rewritting an existing application can be a huge investment. Rewritting a subset of business functions while\nrunning current application in parallel may be relevant and reduce risk and velocity of changes."),Object(a.b)("h3",null,"Solution"),Object(a.b)("p",null,"The approach is to use a “strangler” interface to dispatch request to new or old features. Existing features\nto migrate are selected by trying to isolate sub components."),Object(a.b)("p",null,"One of main challenge is to isolate data store and how the new microservices and the legacy application are accessing\nthe shared data. Continuous data replication can be a solution to propagate write model to read model.\nWrite model will most likely stays on the monolitic application, change data capture can be used, with event backbone to propagate change to read model."),Object(a.b)("p",null,"The facade needs to be scalable and not a single point of failure. It needs to support new APIs (RESTful) and old API (most likely SOAP)."))}l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-patterns-intro-index-mdx-86efdf91c4c4ff563eb1.js.map