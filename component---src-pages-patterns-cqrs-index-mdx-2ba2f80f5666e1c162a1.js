(window.webpackJsonp=window.webpackJsonp||[]).push([[42,84],{"013z":function(e,t,a){"use strict";var n=a("q1tI"),i=a.n(n),s=a("NmYn"),o=a.n(s),r=a("Wbzz"),c=a("Xrax"),d=a("k4MR"),l=a("TSYQ"),h=a.n(l),b=a("QH2O"),m=a.n(b),p=a("qKvR"),u=function(e){var t,a=e.title,n=e.theme,i=e.tabs,s=void 0===i?[]:i;return Object(p.b)("div",{className:h()(m.a.pageHeader,(t={},t[m.a.withTabs]=s.length,t[m.a.darkMode]="dark"===n,t))},Object(p.b)("div",{className:"bx--grid"},Object(p.b)("div",{className:"bx--row"},Object(p.b)("div",{className:"bx--col-lg-12"},Object(p.b)("h1",{id:"page-title",className:m.a.text},a)))))},g=a("BAC9"),f=function(e){var t=e.relativePagePath,a=e.repository,n=Object(r.useStaticQuery)("1364590287").site.siteMetadata.repository,i=a||n,s=i.baseUrl,o=i.subDirectory,c=s+"/edit/"+i.branch+o+"/src/pages"+t;return s?Object(p.b)("div",{className:"bx--row "+g.row},Object(p.b)("div",{className:"bx--col"},Object(p.b)("a",{className:g.link,href:c},"Edit this page on GitHub"))):null},w=a("FCXl"),y=a("dI71"),j=a("I8xM"),O=function(e){function t(){return e.apply(this,arguments)||this}return Object(y.a)(t,e),t.prototype.render=function(){var e=this.props,t=e.title,a=e.tabs,n=e.slug,i=n.split("/").filter(Boolean).slice(-1)[0],s=a.map((function(e){var t,a=o()(e,{lower:!0,strict:!0}),s=a===i,c=new RegExp(i+"/?(#.*)?$"),d=n.replace(c,a);return Object(p.b)("li",{key:e,className:h()((t={},t[j.selectedItem]=s,t),j.listItem)},Object(p.b)(r.Link,{className:j.link,to:""+d},e))}));return Object(p.b)("div",{className:j.tabsContainer},Object(p.b)("div",{className:"bx--grid"},Object(p.b)("div",{className:"bx--row"},Object(p.b)("div",{className:"bx--col-lg-12 bx--col-no-gutter"},Object(p.b)("nav",{"aria-label":t},Object(p.b)("ul",{className:j.list},s))))))},t}(i.a.Component),A=a("MjG9"),v=a("CzIb"),N=a("Asxa"),k=a("OIbQ"),T=a.n(k),x=function(e){var t=e.date,a=new Date(t);return t?Object(p.b)(N.c,{className:T.a.row},Object(p.b)(N.a,null,Object(p.b)("div",{className:T.a.text},"Page last updated: ",a.toLocaleDateString("en-GB",{day:"2-digit",year:"numeric",month:"long"})))):null};t.a=function(e){var t=e.pageContext,a=e.children,n=e.location,i=e.Title,s=t.frontmatter,l=void 0===s?{}:s,h=t.relativePagePath,b=t.titleType,m=l.tabs,g=l.title,y=l.theme,j=l.description,N=l.keywords,k=l.date,T=Object(v.a)().interiorTheme,C=Object(r.useStaticQuery)("2456312558").site.pathPrefix,S=C?n.pathname.replace(C,""):n.pathname,I=m?S.split("/").filter(Boolean).slice(-1)[0]||o()(m[0],{lower:!0}):"",P=y||T;return Object(p.b)(d.a,{tabs:m,homepage:!1,theme:P,pageTitle:g,pageDescription:j,pageKeywords:N,titleType:b},Object(p.b)(u,{title:i?Object(p.b)(i,null):g,label:"label",tabs:m,theme:P}),m&&Object(p.b)(O,{title:g,slug:S,tabs:m,currentTab:I}),Object(p.b)(A.a,{padded:!0},a,Object(p.b)(f,{relativePagePath:h}),Object(p.b)(x,{date:k})),Object(p.b)(w.a,{pageContext:t,location:n,slug:S,tabs:m,currentTab:I}),Object(p.b)(c.a,null))}},BAC9:function(e,t,a){e.exports={bxTextTruncateEnd:"EditLink-module--bx--text-truncate--end--2pqje",bxTextTruncateFront:"EditLink-module--bx--text-truncate--front--3_lIE",link:"EditLink-module--link--1qzW3",row:"EditLink-module--row--1B9Gk"}},Epzf:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return r})),a.d(t,"default",(function(){return m}));var n=a("wx14"),i=a("zLVn"),s=(a("q1tI"),a("7ljp")),o=a("013z"),r=(a("qKvR"),{}),c=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),Object(s.b)("div",t)}},d=c("AnchorLinks"),l=c("AnchorLink"),h={_frontmatter:r},b=o.a;function m(e){var t=e.components,a=Object(i.a)(e,["components"]);return Object(s.b)(b,Object(n.a)({},h,a,{components:t,mdxType:"MDXLayout"}),Object(s.b)("h1",null,"Command-Query Responsibility Segregation (CQRS)"),Object(s.b)(d,{mdxType:"AnchorLinks"},Object(s.b)(l,{mdxType:"AnchorLink"},"Problems and Constraints"),Object(s.b)(l,{mdxType:"AnchorLink"},"Solution and Pattern"),Object(s.b)(l,{mdxType:"AnchorLink"},"Considerations"),Object(s.b)(l,{mdxType:"AnchorLink"},"Combining event sourcing and CQRS"),Object(s.b)(l,{mdxType:"AnchorLink"},"Keeping the write model on Mainframe"),Object(s.b)(l,{mdxType:"AnchorLink"},"The consistency challenges")),Object(s.b)("h2",null,"Problems and Constraints"),Object(s.b)("p",null,"A domain model encapsulates domain data with the behavior for maintaining the correctness of that data as it is modified, structuring the data based on how it is stored in the database and to facilitate managing the data. Multiple clients can independently update the data concurrently. Different clients may not use the data the way the domain model structures it, and may not agree with each other on how it should be structured."),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"When a domain model becomes overburdened managing complex aggregate objects, concurrent updates, and numerous cross-cutting views, how can it be refactored to separate different aspects of how the data is used?")),Object(s.b)("p",null,"An application accesses data both to read and to modify it. The primitive data tasks are often expressed as create, read, update, and delete (CRUD); using them is known as CRUDing the data. Application code often does not make much distinction between the tasks; individual operations may mix reading the data with changing the data as needed."),Object(s.b)("p",null,"This simple approach works well when all clients of the data can use the same structure and contention is low. A single domain model can manage the data, make it accessible as domain objects, and ensure updates maintain its consistency. However, this approach becomes inadaquate when different clients want different views across multiple sets of data, when the data is too widely used, and/or when multiple clients updating the data my unknowlingly conflict with each other."),Object(s.b)("p",null,"For example, in a microservices architecture, each microservice should store and manage its own data, but a user interface may need to display data from several microservices. A query that gathers bits of data from multiple sources can be inefficient (time and bandwidth consumed accessing multiple data sources, CPU consumed transforming data, memory consumed by intermediate objects) and must be repeated each time the data is accessed."),Object(s.b)("p",null,"Another example is an enterprise database of record managing data required by multiple applications. It can become overloaded with too many clients needing too many connections to run too many threads performing too many transactions—such that the database becomes a performance bottleneck and can even crash."),Object(s.b)("p",null,"Another example is maintaining consistency of the data while clients concurrently make independent updates to the data. While each update may be consistent, they may conflict with each other. Database locking ensures that the updates don’t change the same data concurrently, but doesn’t ensure multiple independent changes result in a consistent data model."),Object(s.b)("p",null,"When data usage is more complex than a single domain model can facilitate, a more sophisticated approach is needed."),Object(s.b)("h2",null,"Solution and Pattern"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Refactor a domain model to separate operations for querying data and operations for updating data so that they may be handled independently.")),Object(s.b)("p",null,"The CQRS pattern strictly segregates operations that read data from operations that update data. An operation can read data (the R in CRUD) or can write data (the CUD in CRUD), but not both."),Object(s.b)("p",null,"This separation can make using data much more manageable in several respects. The read operations and the write operations are simpler to implement because their functionality is more finely focused. The operations can be developed independently, potentially by separate teams. The operations can be optimized independently and can evolve independently, following changing user requirements more easily. These optimized operations can scale better, perform better, and security can be applied more precisely."),Object(s.b)("p",null,"The full CQRS pattern uses separate read and write databases. In doing so, the pattern segregates not just the APIs for accessing data or the models for managing data, but even segregates the database itself into two, a read/write database that is effectively write-only and one or more read-only databases."),Object(s.b)("p",null,"The adoption of the pattern can be applied in phases, incrementally from existing code. To illustrate this, we will use four stages that could be used incrementally or a developer can go directly from stage 0 to 3 without considering the others:"),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},"Stage 0: ",Object(s.b)("a",{parentName:"li",href:"#typical-application-data-access"},"Typical application data access")),Object(s.b)("li",{parentName:"ol"},"Stage 1: ",Object(s.b)("a",{parentName:"li",href:"#separate-read-and-write-apis"},"Separate read and write APIs")),Object(s.b)("li",{parentName:"ol"},"Stage 2: ",Object(s.b)("a",{parentName:"li",href:"#separate-read-and-write-models"},"Separate read and write models")),Object(s.b)("li",{parentName:"ol"},"Stage 3: ",Object(s.b)("a",{parentName:"li",href:"#separate-read-and-write-databases"},"Separate read and write databases"))),Object(s.b)("h3",null,"Typical application data access"),Object(s.b)("p",null,"Before even beginning to apply the pattern, let’s consider the typical app design for accessing data. This diagram shows an app with a domain model for accessing data persisted in a database of record, i.e. a single source of truth for that data. The domain model has an API that at a minimum enables clients to perform CRUD tasks on domain objects within the model."),Object(s.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"293px"}},"\n      ",Object(s.b)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"130.55555555555557%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,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')",backgroundSize:"cover",display:"block"}}),"\n  ",Object(s.b)("img",{parentName:"span",className:"gatsby-resp-image-image",alt:"1",title:"1",src:"/refarch-eda/static/ffacf73ec3f0f2d9ae921858b03f2d36/7b711/fig-1.png",srcSet:["/refarch-eda/static/ffacf73ec3f0f2d9ae921858b03f2d36/7fc1e/fig-1.png 288w","/refarch-eda/static/ffacf73ec3f0f2d9ae921858b03f2d36/7b711/fig-1.png 293w"],sizes:"(max-width: 293px) 100vw, 293px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"}),"\n    "),Object(s.b)("p",null,"The ",Object(s.b)("a",{parentName:"p",href:"https://www.martinfowler.com/eaaCatalog/domainModel.html"},"domain model")," is an object representation of the database documents or records. It is comprised of domain objects that represent individual documents or records and the business logic for managing and using them. ",Object(s.b)("a",{parentName:"p",href:"https://dddcommunity.org/learning-ddd/what_is_ddd/"},"Domain-Driven Design")," (DDD) models these domain objects as ",Object(s.b)("a",{parentName:"p",href:"https://martinfowler.com/bliki/EvansClassification.html"},"entities"),"—“objects that have a distinct identity that runs through time and different representations”—and ",Object(s.b)("a",{parentName:"p",href:"https://martinfowler.com/bliki/DDD_Aggregate.html"},"aggregates"),"—“a cluster of domain objects that can be treated as a single unit”; the aggregate root maintains the integrity of the aggregate as a whole."),Object(s.b)("p",null,"Ideally, the domain model’s API should be more domain-specific than simply CRUDing of data. Instead, it should expose higher-level operations that represent business functionality like ",Object(s.b)("inlineCode",{parentName:"p"},"findCustomer()"),", ",Object(s.b)("inlineCode",{parentName:"p"},"placeOrder()"),", ",Object(s.b)("inlineCode",{parentName:"p"},"transferFunds()"),", and so on. These operations read and update data as needed, sometimes doing both in a single operation. They are correct as long as they fit the way the business works."),Object(s.b)("h3",null,"Separate read and write APIs"),Object(s.b)("p",null,"The first and most visible step in applying the CQRS pattern is splitting the CRUD API into separate read and write APIs. This diagram shows the same domain model as before, but its single CRUD API is split into retrieve and modify APIs."),Object(s.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"410px"}},"\n      ",Object(s.b)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"106.94444444444444%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABcSAAAXEgFnn9JSAAAFeklEQVQ4y42Ta0yTZxTHH+jiXGLcTNyWGZY5t5nNmbks88OSqWE6ZLiZjaEwTTaNisKcgCIIbIyL4MACBQb0fkUQLFSQ+6W0tGChtIW29EIvULkKtoCIqLx9zx5wH5a4D5zkl+d9z/mf/3nf5Dlo3FVmXZqvnF+crXBjPCs8wuCcxz1V6qmvSfZIxEkep4XhebIg9jzyPNf8i/vxXKV7bqZyYUDLO2w2CBCaHC2HBzN1cH/qDszMNMD0dB2mHucaYGK8FkxGPhj6mTAyXIVz9VhTD9P361a1M9PP++bcVWC3CCPHhksRspjKva2GcbKuz0XSRHfIPEEtSeVJSE5NJ9k44CbV5j5yaERGNhtmSWFjz6qGJZGTVG41eVPa720amFm22BpgzME+PTvBfm7YZppbbjTMEtm8BuI6v4HIYEiIG+0motn8jFAatITeKiWa8PMtpZ1ILxETeWXtyznCBqJGPU40GhefWexN2JAVPjvBRMjlLAP7SBMMOZvB5myEXm0t6AfvgG24CSyOFnDdq4WpCQmut4DR0gRafR2Yh2rhrroOrI5WcLhaYWZKAk6r8NSkC/+ysZ8XNubgJA9bmEl4yhVNj4BuN/PTx53sK6N2dqLLzktwWPmJYw5GvF7DzRno4+c/mODHdrTxmAppLq1HmZUtbbmemU+L9yspSkTIYeYjm6MA4diEeYVeVP8JQuAzOMRCClUaAoCV2vuY9WHBWX5FNNk7Wj0flQmkH+HcLgzWo+2YdStCBE+0PtfKIv1yqi5+Sm08t01Uw7jEqaEGCnSJ79JqYz/O4IS/GhLqvzFRGLqNd5t2VCgpjshXnvYT1hYdT6JFBAWE7fb/7PMPNq8MnsgXI5TOD99Spske5SkznjClqQslrckLvK6MheLmPx6WqrOA15XO4CrTjghV14DVkTrP6Ux/iLWL3M6rS8z2lPmKgZxFriL1cKH8d1QoTfJFG0Lf2FRuyCOu3YqFGNpJiM47CVfLYyCu+AzJ7soEujKtKqc98SRdlgZRuSfIJHYEJLEjIVV0ARIY50DYlw3ZLVdCq1RUVNGd9RLqUZekyE2Fy4qhYlJpL/HicxXNOIdQDTOgz8E0DNjZkl4XCzRjHKLbSfd2Wou8Cluxt8tBJ2TmQlDpi6v1StHWkd5KhO6PlQO5JPE+W6giljHexWpi0VPh7VVc96qV1OUuWRboemkgb83wrjDq4BDk0u3/6p8+nhOD2Sg477CKEJq4VwaP56tgYVa8yiNcnHdXwqC+BAy6ItD1FYDNzIJ+TQHo1AUwOSp6Qf/QfQvwHp9ZNdT0cILwS8ignh+M+dGkFwSrVYwwvJshZmNlpMlYHTc9KQ7SacTZQxZxxJBZ8L2uj31kQMsJMRkEwSbcZ+znH+loo7+llONN0fVxkXVQiKwm0eqp13JWbtObmK179ny/Xcir3Nkur0dcTvmXBw9d2ILzfpj3Vq5JW3MOGraVI2yM5FI66lZgw34Nl2IziyjYjGK3iChGHZNSXlG4LkM4jTjCm7tYoprwaKbzdXZpTWDTbebmlWlR0T+vH7bhHpNwFYtRQOmUMXxUXSz0QsQX63yjc7vQeerd71K5RkdWqdmdfcO8+JdocD6hRMtH6IIv/kB07E8ZWlMExsopX8fI0f6o9pTQFBX8kqmGE5lq8qfUHjgUpxjbcVS0ceexSrQvot5nTYb+UTLK7jNt6ItzrXGnsjQQXahfPpujI85SdfDNZeWg3yHuhre/5aG9kY1rMwy6rKAEXOxEB6KlycevquHi3/rliFwd8WtePxxO6Bp5bT9r4+YALtq3VsOvojp8Mcj/t7YTAZc6nx6MVXqD4ru9gbFKOBAja/nwB/rLO4IZaG9E/f/2/wPXNMkWgMFsvAAAAABJRU5ErkJggg==')",backgroundSize:"cover",display:"block"}}),"\n  ",Object(s.b)("img",{parentName:"span",className:"gatsby-resp-image-image",alt:"2",title:"2",src:"/refarch-eda/static/7d6c4a4ac35841ed8902e3c8525d78c2/d0f6a/fig-2.png",srcSet:["/refarch-eda/static/7d6c4a4ac35841ed8902e3c8525d78c2/7fc1e/fig-2.png 288w","/refarch-eda/static/7d6c4a4ac35841ed8902e3c8525d78c2/d0f6a/fig-2.png 410w"],sizes:"(max-width: 410px) 100vw, 410px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"}),"\n    "),Object(s.b)("p",null,"The two APIs share the existing domain model but split the behavior:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Read"),": The retrieve API is used to read the existing state of the objects in the domain model without changing that state. The API treats the domain state as read only."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Write"),": The modify API is used to change the objects in the domain model. Changes are made using CUD tasks: create new domain objects, update the state in existing ones, and delete ones that are no longer needed. The operations in this API do not return result values, they return success (ack or void) or failure (nak or throw an exception). The create operation might return the primary of key of the entity, which can be generated either by the domain model or in the data source.")),Object(s.b)("p",null,"This separation of APIs is an application of the ",Object(s.b)("a",{parentName:"p",href:"https://martinfowler.com/bliki/CommandQuerySeparation.html"},"Command Query Separation")," (CQS) pattern, which says to clearly separate methods that change state from those that don’t. To do so, each of an object’s methods can be in one of two categories (but not both):"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Query"),": Returns a result. Does not change the system’s state nor cause any side effects that change the state."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Command")," (a.k.a. modifiers or mutators): Changes the state of a system. Does not return a value, just an indication of success or failure.")),Object(s.b)("p",null,"With this approach, the domain model works the same and provides access to the data the same as before. What has changed is the API for using the domain model. Whereas a higher-level operation might previously have both changed the state of the application and returned a part of that state, now each such operation is redesigned to only do one or the other."),Object(s.b)("p",null,"When the domain model splits its API into read and write operations, clients using the API must likewise split their functionality into querying and updating functionality. Most new web based applications are based in the single page application, with components and services that use and encapsulate remote API. So this separation of backend API fits well with modern web applications."),Object(s.b)("p",null,"This stage depends on the domain model being able to implement both the retrieve and modify APIs. A single domain model requires the retrieve and modify behavior to have similar, corresponding implementations. For them to evolve independently, the two APIs will need to be implemented with separate read and write models."),Object(s.b)("h3",null,"Separate read and write models"),Object(s.b)("p",null,"The second step in applying the CQRS pattern is to split the domain model into separate read and write models. This doesn’t just change the API for accessing domain functionality, it also changes the design of how that functionality is structured and implemented. This diagram shows that the domain model becomes the basis for a write model that handles changes to the domain objects, along with a separate read model used to access the state of the app."),Object(s.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"418px"}},"\n      ",Object(s.b)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"121.18055555555556%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,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')",backgroundSize:"cover",display:"block"}}),"\n  ",Object(s.b)("img",{parentName:"span",className:"gatsby-resp-image-image",alt:"3",title:"3",src:"/refarch-eda/static/a10a0555008bf27c8b1ee80dc117c6b1/bb319/fig-3.png",srcSet:["/refarch-eda/static/a10a0555008bf27c8b1ee80dc117c6b1/7fc1e/fig-3.png 288w","/refarch-eda/static/a10a0555008bf27c8b1ee80dc117c6b1/bb319/fig-3.png 418w"],sizes:"(max-width: 418px) 100vw, 418px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"}),"\n    "),Object(s.b)("p",null,"Naturally, the read model implements the retrieve API and the write model implements the modify API. Now, the application consists not only of separate APIs for querying and updating the domain objects, there’s also separate business functionality for doing so. Both the read business functionality and the write business functionality share the same database."),Object(s.b)("p",null,"The write model is implemented by specializing the domain model to focus solely on maintaining the valid structure of domain objects when changing their state and by applying any business rules."),Object(s.b)("p",null,"Meanwhile, responsibility for returning domain objects is shifted to a separate read model. The read model defines ",Object(s.b)("a",{parentName:"p",href:"https://martinfowler.com/eaaCatalog/dataTransferObject.html"},"data transfer objects")," (DTOs) designed specifically for the model to return just the data the client wants in a structure the client finds convenient. The read model knows how to gather the data used to populate the DTOs. DTOs encapsulate little if any domain functionality, they just bundle data into a convenient package that can easily be transmitted using a single method call, especially between processes."),Object(s.b)("p",null,"The read model should be able to implement the retrieve API by implementing the necessary queries and executing them. If the retrieve API is already built to return domain objects as results, the read model can continue to do so, or better yet, implements DTO types that are compatible with the domain objects and returns those. Likewise, the modify API was already implemented using the domain model, so the write model should preserve that. The write model may enhance the implementation to more explicitly implement a command interface or use command objects."),Object(s.b)("p",null,"This phase assumes that the read and write models can both be implemented using the same database of record the domain model has been using. To the extent this is true, the implementations of reading and writing can evolve independently and be optimized independently. This independence may become increasingly limited since they are both bound to the same database with a single schema or data model. To enable the read and write models to evolve independently, they may each need their own database."),Object(s.b)("h3",null,"Separate read and write databases"),Object(s.b)("p",null,"The third step in applying the CQRS pattern—-which implements the complete CQRS pattern solution—-is splitting the database of record into separate read and write databases. This diagram shows the write model and read model, each supported by its own database. The overall solution consists of two main parts: the write solution that supports updating the data and the read solution that supports querying the data. The two parts are connected by the event bus."),Object(s.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"924px"}},"\n      ",Object(s.b)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"65.27777777777779%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABcSAAAXEgFnn9JSAAAD10lEQVQ4y01TDUxTVxQ+78GrOMRsbo6t0W0ugIsjCLhuUXFiZAkaQShIoUQYNQLyE2EbDFq6Ry32xxZaCq1FQKZmNiADCqWpgJS//tCClZUBQdiPsk3cZrKEbCPZcvdehWQn+XLvOfee73z35FzYz1YFHD2vYgD0YyLjZabcJDBc7izvuWIS9Cksl2IQOgepAikRkVQLEUlKCDkpAQ5fvRWhWpD2f5El7aoYlnVXmuWmqjqAIgyizmgJhMpgbK4VPI+uv3vPo0ZtPZXI7FQg11ITb+ZxC5TW1gdEJNfBfrYauJ9p8DfYNf47RJngmteNtQ9UI4OFRCMe1drvv94JgcgzjQyEnID+MoPtXsOen5ZuGq0W+cDKw5t31552H0bIAhfFeoaPMFkFNdoWHKFqWF+V7Fj+fhCNT1rQiK0PLTy0otWVDg5EpjYScblfAkIIKAui12duUWCx2gljtlH4VN6O7z2l9NtUmFqswoC4hY+ZyrZYR/T82dnbpPeb2+Kx8Wvy4SF1KKVQy3j7OAmdvdNw6KOPIVXkuVignBxMJyea9qQZA3fxFiEqTUtsEobEK7BjOXp/snXIJ6JUNSXkX53Rbjto2NVn9wJNSODvN0CL8WfYBoAfPHs9P082qknmT5S8k9m1haRkszgaglMzh7GrnPixgl4/Vlo9g5U7BBnkwO4siQvlyKYQW2gr+oDXB3CAo2WQjSYozC+hnxxAV0UL2UHwXg8YB3sgJZZJhSXY6YpRyBA5IYW8DxCFgJUooxSegNgS99UTZY5B7FBveO0q1ba34sSMR4t3CJro6S9f53zrbbP399eOTzr0k4vzNxSBQcFhn/DFLyVWThxJqbJzEyqd8RGso/tw/JXgH5Zufbg031w+blUrLL3CvODXmC/D9q8QbjSZwrjZ+leXl7p1To8Zma1daNhuRLNz3e6iC+dD1Lq2sGT+uIZ7yeWgiDsulMuieVnkzqnJa+rZB7onXo92ed7bbIYNC5wWwgu54k5QKgr3NTXmpj2e0x7/+5nh8I/fGULbdOXPm18/BX/+i0BrWYeOK2yQyuSQmJDiO6OAbUwJwOnSzkJhk2sgX+EspoNHMptj+brp5gKlN+mBdxAqJE1+cTwtsZmQJezDYjKUBPqny+dvEFJYg0WqIJz83FHEk8+MsoVuQTr/LnDF7tZcxX2UXu1YAIjB6cvR1NgwWTnAlj2BaI4ei0zR+J9t+A3+bwitAyu73bffTmEnBSadnMR3nONUO1eSBTaVfe4PiM9r8aMJnv+UOghPkGLhiTJi64u76dzXKYRSeJN2DmS04v8B5ATbOV3nym0AAAAASUVORK5CYII=')",backgroundSize:"cover",display:"block"}}),"\n  ",Object(s.b)("img",{parentName:"span",className:"gatsby-resp-image-image",alt:"4",title:"4",src:"/refarch-eda/static/5a86c47dca372fb4a76ff1b48bc77b50/7ff9f/fig-4.png",srcSet:["/refarch-eda/static/5a86c47dca372fb4a76ff1b48bc77b50/7fc1e/fig-4.png 288w","/refarch-eda/static/5a86c47dca372fb4a76ff1b48bc77b50/a5df1/fig-4.png 576w","/refarch-eda/static/5a86c47dca372fb4a76ff1b48bc77b50/7ff9f/fig-4.png 924w"],sizes:"(max-width: 924px) 100vw, 924px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"}),"\n    "),Object(s.b)("p",null,"The write model has its own read/write database and the read model has its own read-only database. The read/write database still serves as the database of record (the single source of truth for the data) but is mostly used write-only: mostly written to and rarely read. Reading is offloaded onto a separate read database that contains the same data but is used read-only."),Object(s.b)("p",null,"The query database is effectively a cache of the database of record, with all of the inherit benefits and complexity of the Caching pattern. The query database contains a copy of the data in the database of record, with the copy structured and staged for easier access by the clients using the retrieve API. As a copy, overhead is needed to keep the copy synchronized with changes in the original. Latency in this synchronization process creates eventual consistency, during which the data copy is stale."),Object(s.b)("p",null,"The separate databases enable the separate read and write models and their respective retrieve and modify APIs to truly evolve independently. Not only can the read model or write model’s implementation change without changing the other, but how each stores its data can be changed independently."),Object(s.b)("p",null,"This solution offers the following advantages:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Scaling"),": The query load is moved from the write database to the read database. If the database of record is a scalability bottleneck and a lot of the load on it is caused by queries, unloading those query responsibilities can significantly improve the scalability of the combined data access."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Performance"),": The schemas of the two databases can be different, enabling them to be designed and optimized independently for better performance. The write database can be optimized for data consistency and correctness, with capabilities such as stored procedures that fit the write model and assist with data updates. The read database can store the data in units that better fit the read model and are better optimized for querying, with larger rows requiring fewer joins.")),Object(s.b)("p",null,"Notice that the design for this stage is significantly more complex than the design for the previous stage. Separate databases with copies of the same data may make data modeling and using data easier, but they require significant overhead to synchronize the data and keep the copies consistent."),Object(s.b)("p",null,"CQRS employs a couple of design features that support keeping the databases synchronized:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Command Bus for queuing commands")," (optional): A more subtle and optional design decision is to queue the commands produced by the modify API, shown in the diagram as the command bus. This can significantly increase the throughput of multiple apps updating the database, as well as serialize updates to help avoid—or at least detect—merge conflicts. With the bus, a client making an update does not block synchronously while the change is written to the database. Rather, the request to change the database is captured as a ",Object(s.b)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Command_pattern"},"command")," (",Object(s.b)("a",{parentName:"li",href:"https://www.pearson.com/us/higher-education/program/Gamma-Design-Patterns-Elements-of-Reusable-Object-Oriented-Software/PGM14333.html"},Object(s.b)("em",{parentName:"a"},"Design Patterns")),") and put on a message queue, after which the client can proceed with other work. Asynchronously in the background, the write model processes the commands at the maximum sustainable rate that the database can handle, without the database ever becoming overloaded. If the database becomes temporarily unavailable, the commands queue and will be processed when the database becomes available once more."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Event Bus for publishing update events")," (required): Whenever the write database is updated, a change notification is published as an event on the event bus. Interested parties can subscribe to the event bus to be notified when the database is updated. One such party is an event processor for the query database, which receives update events and processes them by updating the query database accordingly. In this way, every time the write database is updated, a corresponding update is made to the read database to keep it in sync.")),Object(s.b)("p",null,"The connection between the command bus and the event bus is facilitated by an application of the ",Object(s.b)("a",{parentName:"p",href:"/refarch-eda/patterns/event-sourcing/"},"Event Sourcing pattern"),", which keeps a change log that is suitable for publishing. Event sourcing maintains not only the current state of the data but also the history of how that current state was reached. For each command on the command bus, the write model performs these tasks to process the command:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Logs the change"),Object(s.b)("li",{parentName:"ul"},"Updates the database with the change"),Object(s.b)("li",{parentName:"ul"},"Creates an update event describing the change and publishes it to the event bus")),Object(s.b)("p",null,"The changes that are logged can be the commands from the command bus or the update events published to the event bus"),Object(s.b)("h2",null,"Considerations"),Object(s.b)("p",null,"Keep these decisions in mind while applying this pattern:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Client impact"),": Applying CQRS not only changes how data is stored and accessed, but also changes the APIs that clients use to access data. This means that each client must be redesigned to use the new APIs."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Riskiness"),": A lot of the complexity of the pattern solution involves duplicating the data in two databases and keeping them synchronized. Risk comes from querying data that is stale or downright wrong because of problems with the synchronization."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Eventual consistency"),": Clients querying data must expect that updates will have latency. In a microservices architecture, eventual data consistency is a given and acceptable in many of cases."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Command queuing"),": Using a command bus as part of the write solution to queue the commands is optional but powerful. In addition to the benefits of queuing, the command objects can easily be stored in the change log and easily be converted into notification events. (In the next section, we illustrate a way to use event bus to queue commands as well.)"),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Change log"),": The log of changes to the database of record can be either the list of commands from the command bus or the list of event notifications published on the event bus. The Event Sourcing pattern assumes it’s a log of events, but that pattern doesn’t include the command bus. An event list may be easier to scan as a history, whereas a command list is easier to replay."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Create keys"),": Strick interpretation of the Command Query Separation (CQS) pattern says that command operations do not have return types. A possible exception is commands that create data: An operation that creates a new record or document typically returns the key for accessing the new data, which is convenient for the client. However, if the create operation is invoked asynchronously by a command on a command bus, the write model will need to perform a callback on the client to return the key."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Messaging queues and topics"),": While messaging is used to implement both the command bus and event bus, the two busses use messaging differently. The command bus guarantees exactly once delivery. The event bus broadcasts each event to all interested event processors."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Query database persistence"),": The database of record is always persistent. The query database is a cache that can be a persistent cache or an in-memory cache. If the cache is in-memory and is lost, it must be rebuilt completely from the database of record."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Security"),": Controls on reading data and updating data can be applied separately using the two parts of the solution.")),Object(s.b)("h2",null,"Combining event sourcing and CQRS"),Object(s.b)("p",null,"The CQRS application pattern is frequently associated with event sourcing: when doing event sourcing and domain driven design, we event source the aggregates or root entities. Aggregate creates events that are persisted. On top of the simple create, update and read by ID operations, the business requirements want to perform complex queries that can’t be answered by a single aggregate. By just using event sourcing to be able to respond to a query like “what are the orders of a customer”, then we have to rebuild the history of all orders and filter per customer. It is a lot of computation. This is linked to the problem of having conflicting domain models between query and persistence."),Object(s.b)("p",null,"As introduced in previous section, creations and updates are done as state notification events (change of state), and are persisted in the event log/store. The following figure, presents two separate microservices, one supporting the write model, and multiple other supporting the queries:"),Object(s.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"664px"}},"\n      ",Object(s.b)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"59.02777777777778%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACf0lEQVQoz11T227aQBDl/z+g6kPVKk/pS0WaJlKiBkoCGAI2wYQk3C+JgwHj2/qKbXw6XghSO9JqdzWzZ86cmc2ZloWFqmKj63B9H5phwGYW+q8avlxNUGgt4Lk2NqYJg2J3ux3SFNxSOmT3bMVxwu850w7hhwnCOIXl+lDWBtSNgflCw3C4wHi2hLLa4I3WXF1BZx5sL4TBfDDavTDm7x0/4klyyyVDr/+G4WRBAO8Y0K4sdDA3BmMRsY3g+wk03UOxIuHidw03QgNXlTrEbg/+dkegCXQn3jN0XIZyQ0ah2ELpTobQltEdDHC0Q302YxDEDgoFEdX7DuodGfLL8zHMCQ4lM8fGdVvFWWONX5JOmk3R7fUQJwkSrtcekDkObjoqzpsritugIE3QepRhuwFMxwPziWFWMnOI4aOC0rOJP10Dd/IIzYdH5NtrNGZWRnHPkOKEpyWKXRuFJwd3DyP8LDXx/X6KM3EKVXf3GuqOgfO6gFpLQqUpoiyKkPs9jDUXKxYeAS3HwmmtjNK9hKr0gIrURKndhzBzMVj71JiYq5Nb2DZuB30M5ypGryp603coSwMhCb2Nd3BJm4CEN70A1fEAL5M3Hjd+X1K3A55sG5HfPTTF87dY0jgMRhOoyzXPtN6YtNNs7cDHKYgS6nqAgGLDbUoNIt0shxJreF2sERLgjmtNgB9d8jwPKQFMZnN8PjlB/vISp/k8aiRBZuvVCoqiIE1SuMyFKEn49O0riuXycRo4Qz7tGRKZYVioCHX8uLjEdekWZ1fXEOUO+YlpGBG7CBGxzUxRqUFVgeZ2yv0ZOw74cdgDGtA0Df8b/148cfbVUj5O//gP7zOcv5hTfbOrEbxcAAAAAElFTkSuQmCC')",backgroundSize:"cover",display:"block"}}),"\n  ",Object(s.b)("img",{parentName:"span",className:"gatsby-resp-image-image",alt:"5",title:"5",src:"/refarch-eda/static/8d679dd4fe233589a15cff34d8fed07f/5818d/cqrs-es-api.png",srcSet:["/refarch-eda/static/8d679dd4fe233589a15cff34d8fed07f/7fc1e/cqrs-es-api.png 288w","/refarch-eda/static/8d679dd4fe233589a15cff34d8fed07f/a5df1/cqrs-es-api.png 576w","/refarch-eda/static/8d679dd4fe233589a15cff34d8fed07f/5818d/cqrs-es-api.png 664w"],sizes:"(max-width: 664px) 100vw, 664px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"}),"\n    "),Object(s.b)("p",null,"The query part is separate processes that consume change log events and build a projection for future queries. The “write” part may persist in SQL while the read may use document oriented database with strong indexing and query capabilities. Or use in-memory database, or distributed cache… They do not need to be in the same language. With CQRS and ES the projections are retroactives. New query equals implementing new projection and read the events from the beginning of time or the recent committed state and snapshot. Read and write models are strongly decoupled and can evolve independently. It is important to note that the ‘Command’ part can still handle simple queries, primary-key based, like get order by id, or queries that do not involve joins."),Object(s.b)("p",null,"The event backbone, use a pub/sub model, and Kafka is a good candidate as an implementation technology."),Object(s.b)("p",null,"With this structure, the ",Object(s.b)("inlineCode",{parentName:"p"},"Read model")," microservice will most likely consume events from multiple topics to build the data projection based on joining those data streams. A query, to assess if the cold-chain was respected on the fresh food order shipment, will go to the voyage, container metrics, and order to be able to answer this question. This is where CQRS shines."),Object(s.b)("p",null,"We can note that, we can separate the API definition and management in a API gateway."),Object(s.b)("p",null,"The ",Object(s.b)("a",{parentName:"p",href:"https://github.com/ibm-cloud-architecture/refarch-kc-order-ms"},"shipment order microservice")," is implementing this pattern."),Object(s.b)("p",null,"Some implementation items to consider:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Consistency")," (ensure the data constraints are respected for each data transaction): CQRS without event sourcing has the same consistency guarantees as the database used to persist data and events. With Event Sourcing the consistency could be different, one for the write model and one for the read model. On write model, strong consistency is important to ensure the current state of the system is correct, so it leverages transaction, lock and sharding. On read side, we need less consistency, as they mostly work on stale data. Locking data on the read operation is not reasonable."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Scalability"),": Separating read and write as two different microservices allows for high availability. Caching at the read level can be used to increase performance response time, and can be deployed as multiple standalone instances (Pods in Kubernetes). It is also possible to separate the query implementations between different services. Functions as service / serverless are good technology choices to implement complex queries."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("strong",{parentName:"li"},"Availability"),": The write model sacrafices consistency for availability. This is a fact. The read model is eventually consistent so high availability is possible. In case of failure the system disables the writing of data but still is able to read them as they are served by different databases and services.")),Object(s.b)("p",null,"With CQRS, the write model can evolve over time without impacting the read model, as long as the event model doesn’t change. The read model requires additional tables, but they are often simpler and easier to understand."),Object(s.b)("p",null,"CQRS results in an increased number of objects, with commands, operations, events,… and packaging in deployable components or containers. It adds potentially different type of data sources. It is more complex."),Object(s.b)("p",null,"Some challenges to always consider:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"How to support event structure version management?"),Object(s.b)("li",{parentName:"ul"},"How much data to keep in the event store (history)?"),Object(s.b)("li",{parentName:"ul"},"How to adopt data duplication which results to eventual data consistency?.")),Object(s.b)("p",null,"The CQRS pattern was introduced by ",Object(s.b)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=JHGkaShoyNs"},"Greg Young"),", and described in ",Object(s.b)("a",{parentName:"p",href:"https://martinfowler.com/bliki/CQRS.html"},"Martin Fowler’s work on microservices.")),Object(s.b)("p",null,"As you can see in previous figure, as soon as we see two arrows from the same component, we have to ask ourselves how does it work: the write model has to persist Order in its own database and then sends OrderCreated event to the topic… Should those operations be atomic and controlled with transaction? We detail this in next section."),Object(s.b)("h2",null,"Keeping the write model on Mainframe"),Object(s.b)("p",null,"It is very important to note that the system of records and transaction processing is still easier to run on mainframe to support strong consistency. But with the move to cloud native development, it does not mean we have to move all the system of records to the cloud. Data pipelines can be put in place, but CQRS should help by keeping the write model on the current system of records and without impacting the current MIPS utilization move data in the eventual consistency workd of the cloud native, distributed computing world."),Object(s.b)("p",null," ",Object(s.b)("span",{parentName:"p",className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"513px"}},"\n      ",Object(s.b)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"54.861111111111114%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACTElEQVQoz11SS2sTURTOzxLBlSCIgivXguBCFyrutJhuhIrgoiJYUAouFYQupGkehmljnmPzmjymaScPY1IzeUhDMsnMvZPPc29e4oGZw9xz7ne++c7n4Zyj1+tjNpsBmMHlLhybyYc5DJy5YPSIaHaGKNX7OPk5QKU5wNTmWMb8PuAxTRNPN7wwjCryWhGaVkKlcooqfTcaDYiBNAe9iwluv1Bw9Zkfl5/4cOnhV2hGB9ZoiNHYWoF6Wq027ty9h1xOw0FAweFRDFo+j1JJAFeI3ZzFaXOI++9iePQ+hAc7R7j+PAy93qMKpx62BhyNxgh9C+M4nYXPryCsRImpJsEMw1gBnv0a4uVeDjvhLN4G87i1EcDrzyp2/UU0zaHscQXgUoNioYBETMWPxDGK+QJSKRXZbG413Ti/wM2tEG5sHuKaV8GVxz682dfxMdLA78FoDSikZMxBunyGQCyNYDwHNVtGMpFCJpOda0jRG46xfZCC90Mcm7vEzKfLpSx2sV6KTC7HXrKMrU8hvPqiYD+uQdcK0PUTAmSrZhF/uufgkzEWlKQr+MIFs+Uvu66Lfr8Ps9NFt9uDaXbQarcpd1dAnHoYsbWJ1XTKYFk2nXGp8WRiSwwJKF5LBmNaf63WwIwmF4tlBAJBKIqC79EoLKoJX04nDqLRmKyLqNZqiESoblkEumC4BBV6tYkZczjqtToSiQQtR2iZIaM7cpCYraqqdIA0e7OJZDJJrKeSped/p4tsO47c2L/h0Jk4F1kOp8u2bUsZRKfD5lr/BbGCI+r8g+JnAAAAAElFTkSuQmCC')",backgroundSize:"cover",display:"block"}}),"\n  ",Object(s.b)("img",{parentName:"span",className:"gatsby-resp-image-image",alt:"cqrs mainframe",title:"cqrs mainframe",src:"/refarch-eda/static/702a5c50564cc46a154fa153bcd536a2/fb73d/cqrs-mainframe.png",srcSet:["/refarch-eda/static/702a5c50564cc46a154fa153bcd536a2/7fc1e/cqrs-mainframe.png 288w","/refarch-eda/static/702a5c50564cc46a154fa153bcd536a2/fb73d/cqrs-mainframe.png 513w"],sizes:"(max-width: 513px) 100vw, 513px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"}),"\n    ")),Object(s.b)("p",null,"In the figure above, the write model follows the current transaction processing on the mainframce, change data capture push data to Event backbone for getting real time visibility into the distributed world. The read is the costly operation, dues to the joins to be done to build the projection views needed to expose data depending of the business use cases. This is more true with distributed microservices. All the write operations for the business entities kept in the mainframe’s system of records are still done via the transaction.\nReference data can be injected in one load job to topic and persisted in the event store so streaming applications can leverage them by joining with transactional data. "),Object(s.b)("h2",null,"The consistency challenges"),Object(s.b)("p",null,"As introduced in the previous section, there is a potential problem of data inconsistency: once a command saves changes into the database, the consumers do not see the new or updated data until event notification completes processing."),Object(s.b)("p",null,"With traditional Java service, using JPA and JMS, the save and send operations can be part of the same XA transaction and both succeed or fail."),Object(s.b)("p",null,"With event sourcing pattern, the source of trust is the event source, which acts as a version control system, as shown in the diagram below."),Object(s.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"1152px"}},"\n      ",Object(s.b)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"57.29166666666667%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACPklEQVQoz22T2W7TUBCG8xZIXHPBG/SRihAX5QIJhMRjVEiI5QIuWoFQVVRK0lbdAJEmNE0cr83SJYmzNWnqJN4/ju2mUImRxnM85/g//8w/TiGsknuDaaTpDCZspw+QJAM/CAhDhIeI8NfFI4hyIbd8ZqmR5WKaDr0LD8v26AvQq6nLxAlivxp7Nx6djaI1y1lJvLwS56deAjhxQtqNNtJvmcPvMmpJp3pSw6hWMWpVVL2CahxTPz2LPwiCENf1E+bX9HyRGwnQaJ3yAjhr95hfLPBwUWLhtUSuJKPoKrqmIRVkNENDr1QoKA0y5S5r5T6jsUvoB3iOLy4IYtY3gCfNPvcXctx7XGTueZGiorF/qPLolcyTtxovPpQpywafNyX21A6/agMmdgLgCwB7mpQeAwr2NDomO/kS71Z+sJzOUqtpfNmXuPvggDvzOeaeZjGMKqvbCmtHHXaqFrZ3rUSikuihaIOIKduBknlOXvRrfV9hM6tw1myhVEVOb7G0IfPs5ZbINcmW6/RHTgw2EaVGotluSK1xSas3ThhGl1jWmPNGE7PVJPBFT/wQ23GZTifiXaxtn273QkyDGY9OJEIkThQjW8oUkQwzUTlRLsBxXQaDoQBx4o3L0Yj3Hz/xdWuLlW/r5I+Kcd5xvetKE7DThsnP/KGIXZY3JFLhv1MpzBNNrVTqKKpOZneXjd09VtMZClL5v4Dtbp+CrNIbjigetxOGs5maHRoMh2KurFsXRTue58elcvPX3CYT2R/yUC+4Dg1dUQAAAABJRU5ErkJggg==')",backgroundSize:"cover",display:"block"}}),"\n  ",Object(s.b)("img",{parentName:"span",className:"gatsby-resp-image-image",alt:"6",title:"6",src:"/refarch-eda/static/753baa4311ecb185f4a1d86a1cdfce8e/3cbba/cqrs-es-error-handling.png",srcSet:["/refarch-eda/static/753baa4311ecb185f4a1d86a1cdfce8e/7fc1e/cqrs-es-error-handling.png 288w","/refarch-eda/static/753baa4311ecb185f4a1d86a1cdfce8e/a5df1/cqrs-es-error-handling.png 576w","/refarch-eda/static/753baa4311ecb185f4a1d86a1cdfce8e/3cbba/cqrs-es-error-handling.png 1152w"],sizes:"(max-width: 1152px) 100vw, 1152px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"}),"\n    "),Object(s.b)("p",null,"The steps for syncronizing changes to the data are:"),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},"The write model creates the event and publishes it"),Object(s.b)("li",{parentName:"ol"},"The consumer receives the event and extracts its payload"),Object(s.b)("li",{parentName:"ol"},"The consumer updates its local datasource with the payload data"),Object(s.b)("li",{parentName:"ol"},"If the consumer fails to process the update, it can persist the event to an error log"),Object(s.b)("li",{parentName:"ol"},"Each error in the log can be replayed"),Object(s.b)("li",{parentName:"ol"},"A command line interface replays an event via an admin API, which searches in the topic using this order id to replay the save operation")),Object(s.b)("p",null,"This implementation causes a problem for the ",Object(s.b)("inlineCode",{parentName:"p"},"createOrder(order): string")," operation: The Order Service is supposed to return the new order complete with the order id that is a unique key, a key most likely created by the database. If updating the database fails, there is no new order yet and so no database key to use as the order ID. To avoid this problem, if the underlying technology supports assigning the new order’s key, the service can generate the order ID and use that as the order’s key in the database."),Object(s.b)("p",null,"It is important to clearly study the Kafka consumer API and the different parameters on how to support the read offset. We are addressing those implementation best practices in ",Object(s.b)("a",{parentName:"p",href:"../../technology/kafka-producers-consumers/#kafka-consumers"},"our consumer note.")),Object(s.b)("h3",null,"CQRS and Change Data Capture"),Object(s.b)("p",null,"There are other ways to support this dual operations level:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"When using Kafka, ",Object(s.b)("a",{parentName:"li",href:"https://kafka.apache.org/documentation/#connect"},"Kafka Connect")," has the capability to subscribe to databases via JDBC, allowing to poll tables for updates and then produce events to Kafka."),Object(s.b)("li",{parentName:"ul"},"There is an open-source change data capture solution based on extracting change events from database transaction logs, ",Object(s.b)("a",{parentName:"li",href:"https://debezium.io/"},"Debezium")," that helps to respond to insert, update and delete operations on databases and generate events accordingly. It supports databases like MySQL, Postgres, MongoDB and others."),Object(s.b)("li",{parentName:"ul"},"Write the order to the database and in the same transaction write to an event table (",Object(s.b)("a",{parentName:"li",href:"/refarch-eda/patterns/intro#transactional-outbox"},"“outbox pattern”"),"). Then use a polling to get the events to send to Kafka from this event table and delete the row in the table once the event is sent."),Object(s.b)("li",{parentName:"ul"},"Use the Change Data Capture from the database transaction log and generate events from this log. The IBM ",Object(s.b)("a",{parentName:"li",href:"https://www.ibm.com/support/knowledgecenter/cs/SSTRGZ_10.2.0/com.ibm.cdcdoc.mcadminguide.doc/concepts/overview_of_cdc.html"},"Infosphere CDC")," product helps to implement this pattern. For more detail about this solution see ",Object(s.b)("a",{parentName:"li",href:"https://www.ibm.com/cloud/garage/dte/producttour/ibm-infosphere-data-replication-product-tour"},"this product tour"),".")),Object(s.b)("p",null,"The CQRS implementation using CDC will look like in the following diagram:"),Object(s.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"1152px"}},"\n      ",Object(s.b)("span",{parentName:"span",className:"gatsby-resp-image-background-image",style:{paddingBottom:"57.29166666666667%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACRElEQVQoz22Tz08TURDH+//owZtePRiuauLReDEYlBiJMTEQkRhiMPGgAjE2oGIUbONBgvK7RKglAgWlxsZasFaCsVnbXUq7v3c/vre1gOgkk7f7Zt5nvzPzNlSp6myVDW4MvKdj8AOdkY+c71nk6cw6dfP92to7nOZIyygN7ZMcPDfCcbGathPEyttVHNclZJomJQFs7E3Q2DNK84NJjrXFuBpOklxTmEsXdoh3BfBsd4yW8Bhn7sQ5fWsWw7SDmBTmSqBhGBQ1ncv9i7Q+W6AjusSprjmuP15hJJEmOvtpB9g/meH26xX63qRE3jIn2saJxrNE334l9+NXkBfSBXBbN2m4FuNQ8xSHW6Y50DRO66NltosFlMJPXK8G7HqxytH2GCc74xxtnRElT3N/KsuTeJ5CqSx4HqGqboiSNW6+muVi7zxXwgtc6E4wFPsSQDzXx7QsHMvm+fwqzeEZLnW/o+legoGJNLppUTUsVG2r1kPflwdsfE/0wpMN9rEdh5GlDH2jCR5OJVkvqLhiz7ZFnmsLuCXyncDlniXebTEcyQrVJ+mJslStjKIoKEWVRLbAWDLDROobSsVir0nVwfT51wKFdXccl2KphKZq2KK3mlrCdyz0ahV5GyqVipiqKZ7tHUX7PVS7Z7UXaXL00jKfswwODvFyeJhIJMJado2NjQ3UkhZIc0QLPM+jfv4vhXs3VaFuNZVic3OTfD4v/Du5XA5NNL3+QQmSCv8L3P0bdhXqurikf5L3xqUqGa+v+6uT9hs8DxmWLkTXwQAAAABJRU5ErkJggg==')",backgroundSize:"cover",display:"block"}}),"\n  ",Object(s.b)("img",{parentName:"span",className:"gatsby-resp-image-image",alt:"cqrs cdc",title:"cqrs cdc",src:"/refarch-eda/static/91fd336ae1daaf7a8847203808cb8675/3cbba/cqrs-cdc.png",srcSet:["/refarch-eda/static/91fd336ae1daaf7a8847203808cb8675/7fc1e/cqrs-cdc.png 288w","/refarch-eda/static/91fd336ae1daaf7a8847203808cb8675/a5df1/cqrs-cdc.png 576w","/refarch-eda/static/91fd336ae1daaf7a8847203808cb8675/3cbba/cqrs-cdc.png 1152w","/refarch-eda/static/91fd336ae1daaf7a8847203808cb8675/499f1/cqrs-cdc.png 1238w"],sizes:"(max-width: 1152px) 100vw, 1152px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"}),"\n    "),Object(s.b)("p",null,"What is important to note is that the event needs to be flexible on the data payload. We are presenting a ",Object(s.b)("a",{parentName:"p",href:"https://ibm-cloud-architecture.github.io/refarch-kc-order-ms/#data-and-event-model"},"event model")," in the reference implementation."),Object(s.b)("p",null,"On the view side, updates to the view part need to be idempotent."),Object(s.b)("h3",null,"Delay in the view"),Object(s.b)("p",null,"There is a delay between the data persistence and the availability of the data in the Read model. For most business applications, it is perfectly acceptable. In web based data access most of the data are at stale."),Object(s.b)("p",null,"When there is a need for the client, calling the query operation, to know if the data is up-to-date, the service can define a versioning strategy. When the order data was entered in a form within a single page application like our ",Object(s.b)("a",{parentName:"p",href:"https://github.com/ibm-cloud-architecture/refarch-kc-ui"},"kc- user interface"),", the “create order” operation should return the order with its unique key freshly created and the Single Page Application will have the last data. Here is an example of such operation:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-java"},"@POST\npublic Response create(OrderCreate dto) {\n    Order order = new Order(UUID.randomUUID().toString(), dto.getProductID(),...);\n    // ...\n    return Response.ok().entity(order).build()\n}\n")),Object(s.b)("h3",null,"Schema change"),Object(s.b)("p",null,"What to do when we need to add attribute to event?. So we need to create a versioninig schema for event structure. You need to use flexible schema like json schema, ",Object(s.b)("a",{parentName:"p",href:"https://avro.apache.org/docs/current/"},"Apache Avro")," or ",Object(s.b)("a",{parentName:"p",href:"https://developers.google.com/protocol-buffers/"},"protocol buffer")," and may be, add an event adapter (as a function?) to translate between the different event structures."),Object(s.b)("h3",null,"Code reference"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"The following project includes two sub modules, each deployable as a microservice to illustrate the command and query part: ",Object(s.b)("a",{parentName:"li",href:"https://github.com/ibm-cloud-architecture/refarch-kc-order-ms"},"https://github.com/ibm-cloud-architecture/refarch-kc-order-ms"))),Object(s.b)("h3",null,"Further readings"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://www.codeproject.com/Articles/555855/Introduction-to-CQRS"},"https://www.codeproject.com/Articles/555855/Introduction-to-CQRS")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"http://udidahan.com/2009/12/09/clarified-cqrs/"},"http://udidahan.com/2009/12/09/clarified-cqrs")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://martinfowler.com/bliki/CQRS.html"},"https://martinfowler.com/bliki/CQRS.html")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://microservices.io/patterns/data/cqrs.html"},"https://microservices.io/patterns/data/cqrs.html")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://community.risingstack.com/when-to-use-cqrs"},"https://community.risingstack.com/when-to-use-cqrs")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://dzone.com/articles/concepts-of-cqrs"},"https://dzone.com/articles/concepts-of-cqrs")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://martinfowler.com/bliki/CommandQuerySeparation.html"},"https://martinfowler.com/bliki/CommandQuerySeparation.html")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://www.martinfowler.com/eaaCatalog/domainModel.html"},"https://www.martinfowler.com/eaaCatalog/domainModel.html")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://dddcommunity.org/learning-ddd/what_is_ddd/"},"https://dddcommunity.org/learning-ddd/what_is_ddd/")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://martinfowler.com/bliki/EvansClassification.html"},"https://martinfowler.com/bliki/EvansClassification.html")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://martinfowler.com/bliki/DDD_Aggregate.html"},"https://martinfowler.com/bliki/DDD_Aggregate.html")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://martinfowler.com/eaaCatalog/dataTransferObject.html"},"https://martinfowler.com/eaaCatalog/dataTransferObject.html")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Command_pattern"},"https://en.wikipedia.org/wiki/Command_pattern")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",{parentName:"li",href:"https://www.pearson.com/us/higher-education/program/Gamma-Design-Patterns-Elements-of-Reusable-Object-Oriented-Software/PGM14333.html"},"https://www.pearson.com/us/higher-education/program/Gamma-Design-Patterns-Elements-of-Reusable-Object-Oriented-Software/PGM14333.html"))))}m.isMDXComponent=!0},I8xM:function(e,t,a){e.exports={bxTextTruncateEnd:"PageTabs-module--bx--text-truncate--end--267NA",bxTextTruncateFront:"PageTabs-module--bx--text-truncate--front--3xEQF",tabsContainer:"PageTabs-module--tabs-container--8N4k0",list:"PageTabs-module--list--3eFQc",listItem:"PageTabs-module--list-item--nUmtD",link:"PageTabs-module--link--1mDJ1",selectedItem:"PageTabs-module--selected-item--YPVr3"}},OIbQ:function(e,t,a){e.exports={bxTextTruncateEnd:"last-modified-date-module--bx--text-truncate--end--123zi",bxTextTruncateFront:"last-modified-date-module--bx--text-truncate--front--3xeKz",text:"last-modified-date-module--text--24m-4",row:"last-modified-date-module--row--2BquN"}},QH2O:function(e,t,a){e.exports={bxTextTruncateEnd:"PageHeader-module--bx--text-truncate--end--mZWeX",bxTextTruncateFront:"PageHeader-module--bx--text-truncate--front--3zvrI",pageHeader:"PageHeader-module--page-header--3hIan",darkMode:"PageHeader-module--dark-mode--hBrwL",withTabs:"PageHeader-module--with-tabs--3nKxA",text:"PageHeader-module--text--o9LFq"}}}]);
//# sourceMappingURL=component---src-pages-patterns-cqrs-index-mdx-2ba2f80f5666e1c162a1.js.map