(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{r2Ok:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return o})),a.d(t,"default",(function(){return l}));a("91GP"),a("rGqo"),a("yt8O"),a("Btvt"),a("RW0V"),a("q1tI");var n=a("7ljp"),i=a("013z");a("qKvR");function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}var o={},r={_frontmatter:o},c=i.a;function l(e){var t=e.components,a=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,["components"]);return Object(n.b)(c,s({},r,a,{components:t,mdxType:"MDXLayout"}),Object(n.b)("p",null,"!!! abstract\nIn this article, we are detailing some of the most import event-driven patterns to be used during your microservice implementation and when adopting kafka as an event backbone."),Object(n.b)("p",null,"Adopting messaging (Pub/Sub) as a microservice communication backbone involves using at least the following patterns:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",s({parentName:"li"},{href:"https://microservices.io/patterns/decomposition/decompose-by-subdomain.html"}),"Decompose by subdomain"),", event driven microservices are still microservices, so we need to find them, and the domain-driven subdomains is a good approach to identify and classify business function and therefore microservices. With the event storming method, aggregates help to find those subdomain of responsibility."),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",s({parentName:"li"},{href:"https://microservices.io/patterns/data/database-per-service.html"}),"Database per service")," to enforce each service persists data privately and is accessible only via its API. Services are loosely coupled limiting impact to other service when database schema changes. The database technology is selected from business requirements. The implementation of transactions that span multiple services is complex and enforce using the Saga pattern. Queries that goes over multiple entities is a challenge and CQRS represents an interesting solution."),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",s({parentName:"li"},{href:"#strangler-pattern"}),"Strangler pattern")," is used to incrementally migrate an existing, monolytic application by replacing a set of features to a microservice but keep both running in parallel. Applying a domain driven design approach, you may strangle the application using bounded context. But then aS soon as this pattern is applied, you need to assess the co-existence between existing bounded contexts and the new microservices. One of the challenges will be to define where the write and read operations occurs, and how data should be replicated between the contexts. This is where event driven architecture helps."),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",s({parentName:"li"},{href:"./event-sourcing/"}),"Event sourcing")," persists the state of a business entity such an Order as a sequence of state-changing events."),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",s({parentName:"li"},{href:"./cqrs/"}),"Command Query Responsibility Segregation")," helps to separate queries from commands and help to address queries with cross-microservice boundary."),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",s({parentName:"li"},{href:"./saga/"}),"Saga pattern:")," Microservices publish events when something happens in the scope of their control like an update in the business entities they are responsible for. A microservice interested in other business entities, subscribe to those events and it can update its own states and business entities when receiving such events. Business entity keys needs to be unique, immutable."),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",s({parentName:"li"},{href:"#event-reprocessing-with-dead-letter-pattern"}),"Event reprocessing with dead letter"),": event driven microservice may have to call external service via synchronous call, we need to process failure to get response from those service, using event backbone."),Object(n.b)("li",{parentName:"ul"},Object(n.b)("a",s({parentName:"li"},{href:"https://microservices.io/patterns/data/transactional-outbox.html"}),"Transactional outbox"),": A service command typically needs to update the database and send messages/events. The approach is to use a outbox table to keep the message to sent and a message relay process to publish events inserted into database to the event backbone.")),Object(n.b)("h2",null,"Strangler pattern"),Object(n.b)("h3",null,"Problem"),Object(n.b)("p",null,"How to migrate a monolytics application to microservice without doing a big bang, redeveloping the application from white page. Replacing and rewritting an existing application can be a huge investment. Rewritting a subset of business functions while running current application in parallel may be relevant and reduce risk and velocity of changes."),Object(n.b)("p",null,"The figure below illustrates a typical mainframe application, with external Java based user interface connected to the mainframe via iop/corba and with three\ndifferent applications to manage product, order and customer."),Object(n.b)("img",{src:"../images/stangler.png",alt:null}),Object(n.b)("h3",null,"Solution"),Object(n.b)("p",null,"The approach is to use a “strangler” interface to dispatch request to new or old features. Existing features to migrate are selected by trying to isolate sub components."),Object(n.b)("p",null,"One of main challenge is to isolate data store and how the new microservices and the legacy application are accessing the shared data. Continuous data replication can be a solution to propagate write model to read model. Write model will most likely stays on the monolitic application, change data capture can be used, with event backbone to propagate change to read model."),Object(n.b)("p",null,"The facade needs to be scalable and not a single point of failure. It needs to support new APIs (RESTful) and old API (most likely SOAP)."),Object(n.b)("p",null,"The following figure illustrates an implementation using event driven implementation with\ndata replication from the write model to the read model being on the mainframe."),Object(n.b)("img",{src:"../images/strangler-2.png",alt:null}),Object(n.b)("h2",null,"Transaction outbox"),Object(n.b)("p",null,"See the documentation of the pattern in Chris Richardson’s site / book: ",Object(n.b)("a",s({parentName:"p"},{href:"https://microservices.io/patterns/data/transactional-outbox.html"}),"Transactional outbox"),"."),Object(n.b)("p",null,"A service command typically needs to update the database and send messages/events. The approach is to use a outbox table to keep the message to sent and a message relay process to publish events inserted into database to the event backbone."),Object(n.b)("img",{src:"./images/outbox.png",alt:"2"}))}l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-patterns-ed-patterns-mdx-e60a9a92659065e79114.js.map