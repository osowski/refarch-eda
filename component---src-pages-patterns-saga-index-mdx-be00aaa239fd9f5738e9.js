(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{jn9m:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return r})),n.d(t,"default",(function(){return h}));n("91GP"),n("rGqo"),n("yt8O"),n("Btvt"),n("RW0V"),n("q1tI");var a=n("7ljp"),o=n("013z");n("qKvR");function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var r={},i={_frontmatter:r},c=o.a;function h(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,["components"]);return Object(a.b)(c,s({},i,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",null,"Saga"),Object(a.b)("h2",null,"Problems and Constraints"),Object(a.b)("p",null,"With the adoption of one data source per microservice, there is an interesting challenge on how to support long running transaction cross microservices. With event backbone two phase commit is not an option."),Object(a.b)("h2",null,"Solution and Pattern"),Object(a.b)("p",null,"Introduced in 1987 ",Object(a.b)("a",s({parentName:"p"},{href:"https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf"}),"by Hector Garcaa-Molrna Kenneth Salem paper")," the Saga pattern help to support a long running transaction that can be broken up to a collection of sub transactions that can be interleaved any way with other transactions."),Object(a.b)("p",null,"With microservice each transaction updates data within a single service, each subsequent steps may be triggered by previous completion. The following figure, based on ",Object(a.b)("a",s({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-kc"}),"our solution implementation"),", illustrates those concepts for an order transaction:"),Object(a.b)("img",{src:"images/saga-ctx.png",alt:null}),Object(a.b)("p",null,"When the order is created, the business process says, we need to allocate a “voyage”, assign containers and update the list of containers to load on the ship. Those actions / commands are chained. The final state (in this schema, not in the reality, as the process has more steps) is the Order assigned state in the order microservice."),Object(a.b)("p",null,"With a unique application implementation, the integrity between order, voyage and container tables will be done via transactions. With distributed system we could not apply two phase commit transaction so the Saga pattern will help."),Object(a.b)("p",null,"SAGA pattern supports two types of implementation: Choreography and Orchestration."),Object(a.b)("h2",null,"Services choreography"),Object(a.b)("p",null,"With Choreography each service produces and listens to other service’s events and decides if an action should be taken or not."),Object(a.b)("img",{src:"images/saga-choreo.png",alt:null}),Object(a.b)("p",null,"The first service executes a transaction to its own data store and then publishes an event ( OrderCreated event (1)) as fact about its business entity update. It maintains the business entity status, (order.status) to the ",Object(a.b)("inlineCode",{parentName:"p"},"Pending")," state until the saga is completed. This event is listened by one or more services which execute local transactions and publish new events (VoyageAllocated (3), ReeferAssigned (4), PaymentProcessed (5)).\nThe distributed transaction ends when the last service executes its local transaction or when a service does not publish any events or the event published is not polled by any of the saga’s participants. For example, the Order microservice gets all the events from the other service and changed the Order state to be ",Object(a.b)("inlineCode",{parentName:"p"},"Accepted"),"."),Object(a.b)("p",null,"In case of failure, the source microservice is keeping state and timer to monitor for the expected completion events."),Object(a.b)("img",{src:"images/saga-choreo-fail.png",alt:null}),Object(a.b)("p",null,"When a message from any service is missing, the source service, needs to trigger a compensation process:"),Object(a.b)("img",{src:"images/saga-compensation.png",alt:null}),Object(a.b)("p",null,"Rolling back a distributed transaction does not come for free. Normally you have to implement another operation/transaction to compensate for what has been done before. This will be a new event sent by the service responsible of the transaction integrity. In the order example, in the rare case where one of the service is not able to provide a positive response, no voyage found, or no Reefer container found, then the order needs to change to ‘Uncompleted’ status, and an event to the orders topic will claim the orderID is now uncompleted (OrderUncompleted event Step 1 above) . Any service that has something allocated for this orderId will ‘unroll’ their changes in their own data source  (Steps 2,3,4 below)."),Object(a.b)("p",null,"Also it is important to note, that if one of the service is taking time to answer this may not be a problem as the order is in pending state. If the business requirement stipulates to address an order within a small time period then the compensation process may start. Uncompleted orders can be reviewed by a business user for manual handling. Email can be automatically sent to the customer about issue related to his order. There are a lot of different ways to handle order issue at the business level."),Object(a.b)("h2",null,"Services orchestration"),Object(a.b)("p",null,"With orchestration, one service is responsible to drive each participant on what to do and when."),Object(a.b)("img",{src:"images/saga-ochestration.png",alt:null}),Object(a.b)("p",null,"It uses the different topics to control the saga by issuing event commands to the different service. It uses the event backbone as a queue processing to support the asynchronous invocations. In this case the event should be exactly once delivered and idempotent. Each participant produces response in their context and to the order topic. The orchestration layer needs to keep a state machine and acts once all the expected responses are received."),Object(a.b)("p",null,"If anything fails, the orchestrator is also responsible for coordinating the compensation process by sending rollback events with orderID and their respective impacted entity key (voyageID, reeferID, transactionID). Each  participant will undo its previous operations.\nOrchestrator is a State Machine where each transformation corresponds to a command or message."),Object(a.b)("p",null,"See also ",Object(a.b)("a",s({parentName:"p"},{href:"https://microservices.io/patterns/data/saga.html"}),"this article")," from Chris Richardson on the Saga pattern."),Object(a.b)("p",null,"We have implemented the choreography saga pattern in the order management, voyage and refeer management microservices within the ",Object(a.b)("a",s({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-kc/deployments/reposlist/"}),"EDA reference implementation solution")," with a detailed explanation of the integration tests to validate the ",Object(a.b)("a",s({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-kc/itg-tests/happy-path/happy_path/"}),"happy path"),", and the ",Object(a.b)("a",s({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-kc/itg-tests/saga/saga/"}),"exception path")," with compensation."))}h.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-patterns-saga-index-mdx-be00aaa239fd9f5738e9.js.map